{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Core = void 0;\nvar Modules_1 = require(\"./Modules/Modules\");\nvar LoggerController_1 = require(\"./controllers/LoggerController\");\nvar Config_1 = require(\"./Config/Config\");\nvar CoreConfigSetup_1 = require(\"./Config/CoreConfigSetup\");\nvar version_1 = require(\"./version\");\nvar Error_1 = require(\"./Error\");\nvar dataTypes_1 = require(\"./dataTypes\");\n/**\n * Core is used in all Moralis applications\n * This class is **required** to be implemented in every app\n *\n * This class is responsible for:\n * - registering, removing and accessing modules\n * - accessing and changing the config\n */\nvar Core = /** @class */function () {\n  function Core(modules, config, logger) {\n    var _this = this;\n    this.modules = modules;\n    this.config = config;\n    this.logger = logger;\n    this.name = Core.moduleName;\n    this._isStarted = false;\n    /**\n     * Register all specified modules and configurations\n     * @params array of all modules (any module that is extended from BaseModule) that you want to include\n     */\n    this.registerModules = function (modules) {\n      modules.forEach(_this.registerModule);\n    };\n    /**\n     * Register a new module\n     */\n    this.registerModule = function (module) {\n      if ('create' in module) {\n        module = module.create(_this);\n      }\n      _this.modules.register(module);\n      _this.logger.verbose('Module registered', {\n        module: module.name\n      });\n    };\n    this.getModule = function (name) {\n      return _this.modules.get(name);\n    };\n    /**\n     * Start all modules, this function should be called before any interaction with a module,\n     * as it is responsible for initialising the modules.\n     *\n     * This will call `start()` on every registered module\n     */\n    this.start = function (providedConfig) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var allModules;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (this._isStarted) {\n                throw new Error_1.MoralisError({\n                  message: 'Modules are started already. This method should be called only one time.',\n                  code: Error_1.CoreErrorCode.ALREADY_INITIALIZED\n                });\n              }\n              this._isStarted = true;\n              allModules = this.modules.list();\n              if (providedConfig) {\n                this.config.merge(providedConfig);\n              }\n              this.logger.verbose('Starting all registered modules', {\n                moduleNames: this.modules.listNames()\n              });\n              return [4 /*yield*/, Promise.all(allModules.map(function (module) {\n                return module.start();\n              }))];\n            case 1:\n              _a.sent();\n              this.logger.verbose('Finished starting all registered modules', {\n                moduleNames: this.modules.listNames()\n              });\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n  }\n\n  Core.create = function () {\n    var modules = new Modules_1.Modules();\n    var config = new Config_1.Config();\n    var logger = new LoggerController_1.LoggerController(Core.moduleName, config);\n    var core = new Core(modules, config, logger);\n    CoreConfigSetup_1.CoreConfigSetup.register(config);\n    return core;\n  };\n  Object.defineProperty(Core.prototype, \"isStarted\", {\n    get: function () {\n      return this._isStarted;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Core.prototype, \"BigNumber\", {\n    get: function () {\n      return dataTypes_1.BigNumber;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Core.moduleName = 'core';\n  Core.libVersion = version_1.LIB_VERSION;\n  return Core;\n}();\nexports.Core = Core;","map":{"version":3,"sources":["../src/Core.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Core = void 0;\nvar Modules_1 = require(\"./Modules/Modules\");\nvar LoggerController_1 = require(\"./controllers/LoggerController\");\nvar Config_1 = require(\"./Config/Config\");\nvar CoreConfigSetup_1 = require(\"./Config/CoreConfigSetup\");\nvar version_1 = require(\"./version\");\nvar Error_1 = require(\"./Error\");\nvar dataTypes_1 = require(\"./dataTypes\");\n/**\n * Core is used in all Moralis applications\n * This class is **required** to be implemented in every app\n *\n * This class is responsible for:\n * - registering, removing and accessing modules\n * - accessing and changing the config\n */\nvar Core = /** @class */ (function () {\n    function Core(modules, config, logger) {\n        var _this = this;\n        this.modules = modules;\n        this.config = config;\n        this.logger = logger;\n        this.name = Core.moduleName;\n        this._isStarted = false;\n        /**\n         * Register all specified modules and configurations\n         * @params array of all modules (any module that is extended from BaseModule) that you want to include\n         */\n        this.registerModules = function (modules) {\n            modules.forEach(_this.registerModule);\n        };\n        /**\n         * Register a new module\n         */\n        this.registerModule = function (module) {\n            if ('create' in module) {\n                module = module.create(_this);\n            }\n            _this.modules.register(module);\n            _this.logger.verbose('Module registered', { module: module.name });\n        };\n        this.getModule = function (name) {\n            return _this.modules.get(name);\n        };\n        /**\n         * Start all modules, this function should be called before any interaction with a module,\n         * as it is responsible for initialising the modules.\n         *\n         * This will call `start()` on every registered module\n         */\n        this.start = function (providedConfig) { return __awaiter(_this, void 0, void 0, function () {\n            var allModules;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this._isStarted) {\n                            throw new Error_1.MoralisError({\n                                message: 'Modules are started already. This method should be called only one time.',\n                                code: Error_1.CoreErrorCode.ALREADY_INITIALIZED,\n                            });\n                        }\n                        this._isStarted = true;\n                        allModules = this.modules.list();\n                        if (providedConfig) {\n                            this.config.merge(providedConfig);\n                        }\n                        this.logger.verbose('Starting all registered modules', {\n                            moduleNames: this.modules.listNames(),\n                        });\n                        return [4 /*yield*/, Promise.all(allModules.map(function (module) { return module.start(); }))];\n                    case 1:\n                        _a.sent();\n                        this.logger.verbose('Finished starting all registered modules', {\n                            moduleNames: this.modules.listNames(),\n                        });\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n    }\n    Core.create = function () {\n        var modules = new Modules_1.Modules();\n        var config = new Config_1.Config();\n        var logger = new LoggerController_1.LoggerController(Core.moduleName, config);\n        var core = new Core(modules, config, logger);\n        CoreConfigSetup_1.CoreConfigSetup.register(config);\n        return core;\n    };\n    Object.defineProperty(Core.prototype, \"isStarted\", {\n        get: function () {\n            return this._isStarted;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Core.prototype, \"BigNumber\", {\n        get: function () {\n            return dataTypes_1.BigNumber;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Core.moduleName = 'core';\n    Core.libVersion = version_1.LIB_VERSION;\n    return Core;\n}());\nexports.Core = Core;\n//# sourceMappingURL=Core.js.map"]},"metadata":{},"sourceType":"script"}