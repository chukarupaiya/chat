{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;\nvar externals_1 = require(\"./externals\");\nvar internal_1 = require(\"./internal\");\nvar bytes_1 = require(\"./bytes\");\n/**\n * Convert BN to 0x-prefixed hex string.\n */\nfunction bnToHex(value) {\n  return \"0x\".concat(value.toString(16));\n}\nexports.bnToHex = bnToHex;\n/**\n * Convert value from BN to an unpadded Buffer\n * (useful for RLP transport)\n * @param value value to convert\n */\nfunction bnToUnpaddedBuffer(value) {\n  // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`\n  // for compatibility with browserify and similar tools\n  return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));\n}\nexports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;\n/**\n * Deprecated alias for {@link bnToUnpaddedBuffer}\n * @deprecated\n */\nfunction bnToRlp(value) {\n  return bnToUnpaddedBuffer(value);\n}\nexports.bnToRlp = bnToRlp;\n/**\n * Type output options\n */\nvar TypeOutput;\n(function (TypeOutput) {\n  TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n  TypeOutput[TypeOutput[\"BN\"] = 1] = \"BN\";\n  TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n  TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n  if (input === null) {\n    return null;\n  }\n  if (input === undefined) {\n    return undefined;\n  }\n  if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\n    throw new Error(\"A string must be provided with a 0x-prefix, given: \".concat(input));\n  } else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n    throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n  }\n  var output = (0, bytes_1.toBuffer)(input);\n  if (outputType === TypeOutput.Buffer) {\n    return output;\n  } else if (outputType === TypeOutput.BN) {\n    return new externals_1.BN(output);\n  } else if (outputType === TypeOutput.Number) {\n    var bn = new externals_1.BN(output);\n    var max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());\n    if (bn.gt(max)) {\n      throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n    }\n    return bn.toNumber();\n  } else {\n    // outputType === TypeOutput.PrefixedHexString\n    return \"0x\".concat(output.toString('hex'));\n  }\n}\nexports.toType = toType;","map":{"version":3,"sources":["../src/types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;\nvar externals_1 = require(\"./externals\");\nvar internal_1 = require(\"./internal\");\nvar bytes_1 = require(\"./bytes\");\n/**\n * Convert BN to 0x-prefixed hex string.\n */\nfunction bnToHex(value) {\n    return \"0x\".concat(value.toString(16));\n}\nexports.bnToHex = bnToHex;\n/**\n * Convert value from BN to an unpadded Buffer\n * (useful for RLP transport)\n * @param value value to convert\n */\nfunction bnToUnpaddedBuffer(value) {\n    // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`\n    // for compatibility with browserify and similar tools\n    return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));\n}\nexports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;\n/**\n * Deprecated alias for {@link bnToUnpaddedBuffer}\n * @deprecated\n */\nfunction bnToRlp(value) {\n    return bnToUnpaddedBuffer(value);\n}\nexports.bnToRlp = bnToRlp;\n/**\n * Type output options\n */\nvar TypeOutput;\n(function (TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BN\"] = 1] = \"BN\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n    if (input === null) {\n        return null;\n    }\n    if (input === undefined) {\n        return undefined;\n    }\n    if (typeof input === 'string' && !(0, internal_1.isHexString)(input)) {\n        throw new Error(\"A string must be provided with a 0x-prefix, given: \".concat(input));\n    }\n    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');\n    }\n    var output = (0, bytes_1.toBuffer)(input);\n    if (outputType === TypeOutput.Buffer) {\n        return output;\n    }\n    else if (outputType === TypeOutput.BN) {\n        return new externals_1.BN(output);\n    }\n    else if (outputType === TypeOutput.Number) {\n        var bn = new externals_1.BN(output);\n        var max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());\n        if (bn.gt(max)) {\n            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');\n        }\n        return bn.toNumber();\n    }\n    else {\n        // outputType === TypeOutput.PrefixedHexString\n        return \"0x\".concat(output.toString('hex'));\n    }\n}\nexports.toType = toType;\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"script"}