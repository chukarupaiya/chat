{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defineProperties = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar internal_1 = require(\"./internal\");\nvar externals_1 = require(\"./externals\");\nvar bytes_1 = require(\"./bytes\");\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n * @deprecated\n */\nvar defineProperties = function (self, fields, data) {\n  self.raw = [];\n  self._fields = [];\n  // attach the `toJSON`\n  self.toJSON = function (label) {\n    if (label === void 0) {\n      label = false;\n    }\n    if (label) {\n      var obj_1 = {};\n      self._fields.forEach(function (field) {\n        obj_1[field] = \"0x\".concat(self[field].toString('hex'));\n      });\n      return obj_1;\n    }\n    return (0, bytes_1.baToJSON)(self.raw);\n  };\n  self.serialize = function serialize() {\n    return externals_1.rlp.encode(self.raw);\n  };\n  fields.forEach(function (field, i) {\n    self._fields.push(field.name);\n    function getter() {\n      return self.raw[i];\n    }\n    function setter(v) {\n      v = (0, bytes_1.toBuffer)(v);\n      if (v.toString('hex') === '00' && !field.allowZero) {\n        v = Buffer.allocUnsafe(0);\n      }\n      if (field.allowLess && field.length) {\n        v = (0, bytes_1.unpadBuffer)(v);\n        (0, assert_1.default)(field.length >= v.length, \"The field \".concat(field.name, \" must not have more \").concat(field.length, \" bytes\"));\n      } else if (!(field.allowZero && v.length === 0) && field.length) {\n        (0, assert_1.default)(field.length === v.length, \"The field \".concat(field.name, \" must have byte length of \").concat(field.length));\n      }\n      self.raw[i] = v;\n    }\n    Object.defineProperty(self, field.name, {\n      enumerable: true,\n      configurable: true,\n      get: getter,\n      set: setter\n    });\n    if (field.default) {\n      self[field.name] = field.default;\n    }\n    // attach alias\n    if (field.alias) {\n      Object.defineProperty(self, field.alias, {\n        enumerable: false,\n        configurable: true,\n        set: setter,\n        get: getter\n      });\n    }\n  });\n  // if the constuctor is passed data\n  if (data) {\n    if (typeof data === 'string') {\n      data = Buffer.from((0, internal_1.stripHexPrefix)(data), 'hex');\n    }\n    if (Buffer.isBuffer(data)) {\n      data = externals_1.rlp.decode(data);\n    }\n    if (Array.isArray(data)) {\n      if (data.length > self._fields.length) {\n        throw new Error('wrong number of fields in data');\n      }\n      // make sure all the items are buffers\n      data.forEach(function (d, i) {\n        self[self._fields[i]] = (0, bytes_1.toBuffer)(d);\n      });\n    } else if (typeof data === 'object') {\n      var keys_1 = Object.keys(data);\n      fields.forEach(function (field) {\n        if (keys_1.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n        if (keys_1.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n      });\n    } else {\n      throw new Error('invalid data');\n    }\n  }\n};\nexports.defineProperties = defineProperties;","map":{"version":3,"sources":["../src/object.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defineProperties = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar internal_1 = require(\"./internal\");\nvar externals_1 = require(\"./externals\");\nvar bytes_1 = require(\"./bytes\");\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n * @deprecated\n */\nvar defineProperties = function (self, fields, data) {\n    self.raw = [];\n    self._fields = [];\n    // attach the `toJSON`\n    self.toJSON = function (label) {\n        if (label === void 0) { label = false; }\n        if (label) {\n            var obj_1 = {};\n            self._fields.forEach(function (field) {\n                obj_1[field] = \"0x\".concat(self[field].toString('hex'));\n            });\n            return obj_1;\n        }\n        return (0, bytes_1.baToJSON)(self.raw);\n    };\n    self.serialize = function serialize() {\n        return externals_1.rlp.encode(self.raw);\n    };\n    fields.forEach(function (field, i) {\n        self._fields.push(field.name);\n        function getter() {\n            return self.raw[i];\n        }\n        function setter(v) {\n            v = (0, bytes_1.toBuffer)(v);\n            if (v.toString('hex') === '00' && !field.allowZero) {\n                v = Buffer.allocUnsafe(0);\n            }\n            if (field.allowLess && field.length) {\n                v = (0, bytes_1.unpadBuffer)(v);\n                (0, assert_1.default)(field.length >= v.length, \"The field \".concat(field.name, \" must not have more \").concat(field.length, \" bytes\"));\n            }\n            else if (!(field.allowZero && v.length === 0) && field.length) {\n                (0, assert_1.default)(field.length === v.length, \"The field \".concat(field.name, \" must have byte length of \").concat(field.length));\n            }\n            self.raw[i] = v;\n        }\n        Object.defineProperty(self, field.name, {\n            enumerable: true,\n            configurable: true,\n            get: getter,\n            set: setter,\n        });\n        if (field.default) {\n            self[field.name] = field.default;\n        }\n        // attach alias\n        if (field.alias) {\n            Object.defineProperty(self, field.alias, {\n                enumerable: false,\n                configurable: true,\n                set: setter,\n                get: getter,\n            });\n        }\n    });\n    // if the constuctor is passed data\n    if (data) {\n        if (typeof data === 'string') {\n            data = Buffer.from((0, internal_1.stripHexPrefix)(data), 'hex');\n        }\n        if (Buffer.isBuffer(data)) {\n            data = externals_1.rlp.decode(data);\n        }\n        if (Array.isArray(data)) {\n            if (data.length > self._fields.length) {\n                throw new Error('wrong number of fields in data');\n            }\n            // make sure all the items are buffers\n            data.forEach(function (d, i) {\n                self[self._fields[i]] = (0, bytes_1.toBuffer)(d);\n            });\n        }\n        else if (typeof data === 'object') {\n            var keys_1 = Object.keys(data);\n            fields.forEach(function (field) {\n                if (keys_1.indexOf(field.name) !== -1)\n                    self[field.name] = data[field.name];\n                if (keys_1.indexOf(field.alias) !== -1)\n                    self[field.alias] = data[field.alias];\n            });\n        }\n        else {\n            throw new Error('invalid data');\n        }\n    }\n};\nexports.defineProperties = defineProperties;\n//# sourceMappingURL=object.js.map"]},"metadata":{},"sourceType":"script"}