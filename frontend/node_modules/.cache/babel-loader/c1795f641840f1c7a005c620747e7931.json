{"ast":null,"code":"\"use strict\";\n\n/**\n * Copied (and remove obsolete functionalities) from https://github.com/aptos-labs/aptos-core/blob/main/ecosystem/typescript/sdk/src/aptos_types/account_address.ts because\n * - We only care about address validation and conversion\n * - Resolving this dependency in UMD gives dependency errors\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AccountAddress = void 0;\nvar HexString_1 = require(\"./HexString\");\nvar AccountAddress = /** @class */function () {\n  function AccountAddress(address) {\n    if (address.length !== AccountAddress.LENGTH) {\n      throw new Error('Expected address of length 32');\n    }\n    this.address = address;\n  }\n  /**\n   * Creates AccountAddress from a hex string.\n   * @param addr Hex string can be with a prefix or without a prefix,\n   *   e.g. '0x1aa' or '1aa'. Hex string will be left padded with 0s if too short.\n   */\n  AccountAddress.fromHex = function (addr) {\n    var address = HexString_1.HexString.ensure(addr);\n    // If an address hex has odd number of digits, padd the hex string with 0\n    // e.g. '1aa' would become '01aa'.\n    if (address.noPrefix().length % 2 !== 0) {\n      address = new HexString_1.HexString(\"0\".concat(address.noPrefix()));\n    }\n    var addressBytes = address.toUint8Array();\n    if (addressBytes.length > AccountAddress.LENGTH) {\n      // eslint-disable-next-line quotes\n      throw new Error(\"Hex string is too long. Address's length is 32 bytes.\");\n    } else if (addressBytes.length === AccountAddress.LENGTH) {\n      return new AccountAddress(addressBytes);\n    }\n    var res = new Uint8Array(AccountAddress.LENGTH);\n    res.set(addressBytes, AccountAddress.LENGTH - addressBytes.length);\n    return new AccountAddress(res);\n  };\n  /**\n   * Checks if the string is a valid AccountAddress\n   * @param addr Hex string can be with a prefix or without a prefix,\n   *   e.g. '0x1aa' or '1aa'. Hex string will be left padded with 0s if too short.\n   */\n  AccountAddress.isValid = function (addr) {\n    // At least one zero is required\n    if (addr === '') {\n      return false;\n    }\n    var address = HexString_1.HexString.ensure(addr);\n    // If an address hex has odd number of digits, padd the hex string with 0\n    // e.g. '1aa' would become '01aa'.\n    if (address.noPrefix().length % 2 !== 0) {\n      address = new HexString_1.HexString(\"0\".concat(address.noPrefix()));\n    }\n    var addressBytes = address.toUint8Array();\n    return addressBytes.length <= AccountAddress.LENGTH;\n  };\n  AccountAddress.LENGTH = 32;\n  AccountAddress.CORE_CODE_ADDRESS = AccountAddress.fromHex('0x1');\n  return AccountAddress;\n}();\nexports.AccountAddress = AccountAddress;","map":{"version":3,"sources":["../../src/utils/AccountAddress.ts"],"names":[],"mappings":";;AAAA;;;;AAIG;;;;;AAEH,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAIA,IAAA,cAAA,GAAA,aAAA,YAAA;EAOE,SAAA,cAAA,CAAY,OAAc,EAAA;IACxB,IAAI,OAAO,CAAC,MAAM,KAAK,cAAc,CAAC,MAAM,EAAE;MAC5C,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC;IACjD;IACD,IAAI,CAAC,OAAO,GAAG,OAAO;EACxB;EAEA;;;;AAIG;EACI,cAAA,CAAA,OAAO,GAAd,UAAe,IAAoB,EAAA;IACjC,IAAI,OAAO,GAAG,WAAA,CAAA,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC;IAEpC;IACA;IACA,IAAI,OAAO,CAAC,QAAQ,EAAE,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;MACvC,OAAO,GAAG,IAAI,WAAA,CAAA,SAAS,CAAC,GAAA,CAAA,MAAA,CAAI,OAAO,CAAC,QAAQ,EAAE,CAAE,CAAC;IAClD;IAED,IAAM,YAAY,GAAG,OAAO,CAAC,YAAY,EAAE;IAE3C,IAAI,YAAY,CAAC,MAAM,GAAG,cAAc,CAAC,MAAM,EAAE;MAC/C;MACA,MAAM,IAAI,KAAK,CAAC,uDAAuD,CAAC;KACzE,MAAM,IAAI,YAAY,CAAC,MAAM,KAAK,cAAc,CAAC,MAAM,EAAE;MACxD,OAAO,IAAI,cAAc,CAAC,YAAY,CAAC;IACxC;IAED,IAAM,GAAG,GAAU,IAAI,UAAU,CAAC,cAAc,CAAC,MAAM,CAAC;IACxD,GAAG,CAAC,GAAG,CAAC,YAAY,EAAE,cAAc,CAAC,MAAM,GAAG,YAAY,CAAC,MAAM,CAAC;IAElE,OAAO,IAAI,cAAc,CAAC,GAAG,CAAC;EAChC,CAAC;EAED;;;;AAIG;EACI,cAAA,CAAA,OAAO,GAAd,UAAe,IAAoB,EAAA;IACjC;IACA,IAAI,IAAI,KAAK,EAAE,EAAE;MACf,OAAO,KAAK;IACb;IAED,IAAI,OAAO,GAAG,WAAA,CAAA,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC;IAEpC;IACA;IACA,IAAI,OAAO,CAAC,QAAQ,EAAE,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;MACvC,OAAO,GAAG,IAAI,WAAA,CAAA,SAAS,CAAC,GAAA,CAAA,MAAA,CAAI,OAAO,CAAC,QAAQ,EAAE,CAAE,CAAC;IAClD;IAED,IAAM,YAAY,GAAG,OAAO,CAAC,YAAY,EAAE;IAE3C,OAAO,YAAY,CAAC,MAAM,IAAI,cAAc,CAAC,MAAM;EACrD,CAAC;EAhEe,cAAA,CAAA,MAAM,GAAW,EAAE;EAI5B,cAAA,CAAA,iBAAiB,GAAmB,cAAc,CAAC,OAAO,CAAC,KAAK,CAAC;EA6D1E,OAAA,cAAC;CAAA,EAAA;AAlEY,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copied (and remove obsolete functionalities) from https://github.com/aptos-labs/aptos-core/blob/main/ecosystem/typescript/sdk/src/aptos_types/account_address.ts because\n * - We only care about address validation and conversion\n * - Resolving this dependency in UMD gives dependency errors\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AccountAddress = void 0;\nvar HexString_1 = require(\"./HexString\");\nvar AccountAddress = /** @class */ (function () {\n    function AccountAddress(address) {\n        if (address.length !== AccountAddress.LENGTH) {\n            throw new Error('Expected address of length 32');\n        }\n        this.address = address;\n    }\n    /**\n     * Creates AccountAddress from a hex string.\n     * @param addr Hex string can be with a prefix or without a prefix,\n     *   e.g. '0x1aa' or '1aa'. Hex string will be left padded with 0s if too short.\n     */\n    AccountAddress.fromHex = function (addr) {\n        var address = HexString_1.HexString.ensure(addr);\n        // If an address hex has odd number of digits, padd the hex string with 0\n        // e.g. '1aa' would become '01aa'.\n        if (address.noPrefix().length % 2 !== 0) {\n            address = new HexString_1.HexString(\"0\".concat(address.noPrefix()));\n        }\n        var addressBytes = address.toUint8Array();\n        if (addressBytes.length > AccountAddress.LENGTH) {\n            // eslint-disable-next-line quotes\n            throw new Error(\"Hex string is too long. Address's length is 32 bytes.\");\n        }\n        else if (addressBytes.length === AccountAddress.LENGTH) {\n            return new AccountAddress(addressBytes);\n        }\n        var res = new Uint8Array(AccountAddress.LENGTH);\n        res.set(addressBytes, AccountAddress.LENGTH - addressBytes.length);\n        return new AccountAddress(res);\n    };\n    /**\n     * Checks if the string is a valid AccountAddress\n     * @param addr Hex string can be with a prefix or without a prefix,\n     *   e.g. '0x1aa' or '1aa'. Hex string will be left padded with 0s if too short.\n     */\n    AccountAddress.isValid = function (addr) {\n        // At least one zero is required\n        if (addr === '') {\n            return false;\n        }\n        var address = HexString_1.HexString.ensure(addr);\n        // If an address hex has odd number of digits, padd the hex string with 0\n        // e.g. '1aa' would become '01aa'.\n        if (address.noPrefix().length % 2 !== 0) {\n            address = new HexString_1.HexString(\"0\".concat(address.noPrefix()));\n        }\n        var addressBytes = address.toUint8Array();\n        return addressBytes.length <= AccountAddress.LENGTH;\n    };\n    AccountAddress.LENGTH = 32;\n    AccountAddress.CORE_CODE_ADDRESS = AccountAddress.fromHex('0x1');\n    return AccountAddress;\n}());\nexports.AccountAddress = AccountAddress;\n//# sourceMappingURL=AccountAddress.js.map"]},"metadata":{},"sourceType":"script"}