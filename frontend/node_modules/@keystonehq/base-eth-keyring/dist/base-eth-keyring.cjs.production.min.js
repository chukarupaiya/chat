"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t,i,r=(e=require("hdkey"))&&"object"==typeof e&&"default"in e?e.default:e,s=require("ethereumjs-util"),n=require("@ethereumjs/tx"),a=require("@keystonehq/bc-ur-registry-eth"),o=require("uuid");!function(e){e.hd="hd",e.pubkey="pubkey"}(t||(t={})),function(e){e.standard="account.standard",e.ledger_live="account.ledger_live",e.ledger_legacy="account.ledger_legacy"}(i||(i={}));class h{constructor(e){this.version=1,this.getInteraction=()=>{throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.")},this.type="QR Hardware Wallet Device",this.requestSignature=async(e,t,i,r)=>{const s=await this.getInteraction().requestSignature(t,i,r),n=s.getRequestId(),a=s.getSignature();if(n&&o.stringify(n)!==e)throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");return{r:a.slice(0,32),s:a.slice(32,64),v:a.slice(64)}},this.__readCryptoHDKey=e=>{var t,r;const s="m/"+e.getOrigin().getPath(),n=null==(t=e.getOrigin().getSourceFingerprint())?void 0:t.toString("hex"),a=(null==(r=e.getChildren())?void 0:r.getPath())||"0/*",o=e.getName();if(e.getNote()===i.standard?this.keyringAccount=i.standard:e.getNote()===i.ledger_legacy&&(this.keyringAccount=i.ledger_legacy),!n)throw new Error("KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint");const h=e.getBip32Key();this.xfp=n,this.xpub=h,this.hdPath=s,this.childrenPath=a,void 0!==o&&""!==o&&(this.name=o),this.initialized=!0},this.__readCryptoAccount=e=>{var t,r;const n=null==(t=e.getMasterFingerprint())?void 0:t.toString("hex");if(!n)throw new Error("KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint");this.xfp=n,this.initialized=!0;let a=!1;const o=e.getOutputDescriptors();if(!o||0===o.length)throw new Error("KeystoneError#invalid_data: invalid crypto-account, no crypto output found");if(o.length%5!=0)throw new Error("KeystoneError#invalid_data: only support 5x pubkey accounts for now");return null==(r=e.getOutputDescriptors())||r.forEach(e=>{try{const t=e.getHDKey();if(t){const e=t.getKey(),r="M/"+t.getOrigin().getPath(),n="0x"+s.publicToAddress(e,!0).toString("hex");this.name=t.getName(),t.getNote()===i.ledger_live&&(this.keyringAccount=i.ledger_live),void 0===this.paths[s.toChecksumAddress(n)]&&(a=!0),this.paths[s.toChecksumAddress(n)]=r}}catch(e){throw new Error("KeystoneError#invalid_data: "+e)}}),a},this.getName=()=>this.name,this.setAccountToUnlock=e=>{this.unlockedAccount=parseInt(e,10)},this.__getNormalPage=async e=>{this.page+=e,this.page<=0&&(this.page=1);const t=(this.page-1)*this.perPage,i=t+this.perPage,r=[];for(let e=t;e<i;e++){const t=await this.__addressFromIndex("m",e);r.push({address:t,balance:null,index:e}),this.indexes[s.toChecksumAddress(t)]=e}return r},this.__getLedgerLivePage=async e=>{const t=(this.page+e-1)*this.perPage,i=t+this.perPage,r=[];for(let e=t;e<i;e++){const t=await this.__addressFromIndex("m",e);r.push({address:t,balance:null,index:e})}return this.page+=e,r},this.__addressFromIndex=async(e,i)=>{if(this.keyringMode===t.hd){this.checkKeyring(),this.hdk||(this.hdk=r.fromExtendedKey(this.xpub));const t=this.childrenPath.replace("*",String(i)).replace(/\*/g,"0"),n=this.hdk.derive(`${e}/${t}`),a="0x"+s.publicToAddress(n.publicKey,!0).toString("hex");return s.toChecksumAddress(a)}{const e=Object.keys(this.paths)[i];if(e)return s.toChecksumAddress(e);throw new Error("KeystoneError#pubkey_account.no_expected_account")}},this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.unlockedAccount=0,this.name="QR Hardware",this.keyringMode=t.hd,this.keyringAccount=i.standard,this.initialized=!1,this.xfp="",this.xpub="",this.hdPath="",this.childrenPath="0/*",this.indexes={},this.paths={},this.deserialize(e)}async readKeyring(){const e=await this.getInteraction().readCryptoHDKeyOrCryptoAccount();this.syncKeyring(e)}syncKeyring(e){e.getRegistryType().getType()===a.extend.RegistryTypes.CRYPTO_HDKEY.getType()?(this.keyringMode=t.hd,this.__readCryptoHDKey(e)):(this.keyringMode=t.pubkey,this.__readCryptoAccount(e))}checkKeyring(){if(!this.xfp||!this.xpub||!this.hdPath)throw new Error("KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly")}serialize(){return Promise.resolve({initialized:this.initialized,accounts:this.accounts,currentAccount:this.currentAccount,page:this.page,perPage:this.perPage,keyringAccount:this.keyringAccount,keyringMode:this.keyringMode,name:this.name,version:this.version,xfp:this.xfp,xpub:this.xpub,hdPath:this.hdPath,childrenPath:this.childrenPath,indexes:this.indexes,paths:this.paths})}deserialize(e){e&&(this.accounts=e.accounts,this.currentAccount=e.currentAccount,this.page=e.page,this.perPage=e.perPage,this.name=e.name,this.initialized=e.initialized,this.keyringMode=e.keyringMode||t.hd,this.keyringAccount=e.keyringAccount||i.standard,this.xfp=e.xfp,this.xpub=e.xpub,this.hdPath=e.hdPath,this.indexes=e.indexes,this.paths=e.paths,this.childrenPath=e.childrenPath||"0/*")}setCurrentAccount(e){this.currentAccount=e}getCurrentAccount(){return this.currentAccount}getCurrentAddress(){return this.accounts[this.currentAccount]}async addAccounts(e=1){const t=this.unlockedAccount,i=t+e,r=[];for(let e=t;e<i;e++){const t=await this.__addressFromIndex("m",e);r.push(t),this.page=0,this.unlockedAccount++}return this.accounts=this.accounts.concat(r),this.accounts}getFirstPage(){return this.page=0,this.__getPage(1)}getNextPage(){return this.__getPage(1)}getPreviousPage(){return this.__getPage(-1)}async __getPage(e){return this.initialized||await this.readKeyring(),this.keyringMode===t.hd?this.__getNormalPage(e):this.__getLedgerLivePage(e)}getAccounts(){return Promise.resolve(this.accounts)}removeAccount(e){if(!this.accounts.map(e=>e.toLowerCase()).includes(e.toLowerCase()))throw new Error(`Address ${e} not found in this keyring`);this.accounts=this.accounts.filter(t=>t.toLowerCase()!==e.toLowerCase())}static serializeTx(e){return e.v=new s.BN(e.common.chainId()),e.r=new s.BN(0),e.s=new s.BN(0),e.serialize()}async signTransaction(e,t){const i=await this._pathFromAddress(e),r=t.common.chainId(),s=o.v4(),c=a.EthSignRequest.constructETHRequest(h.serializeTx(t),a.DataType.transaction,i,this.xfp,s,r),{r:d,s:u,v:g}=await this.requestSignature(s,c,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature'),l=t.toJSON();return n.Transaction.fromTxData({to:l.to,gasLimit:l.gasLimit,gasPrice:l.gasPrice,data:l.data,nonce:l.nonce,value:l.value,r:d,s:u,v:g},{common:t.common})}signMessage(e,t){return this.signPersonalMessage(e,t)}async signPersonalMessage(e,t){const i=s.stripHexPrefix(t),r=await this._pathFromAddress(e),n=o.v4(),h=a.EthSignRequest.constructETHRequest(Buffer.from(i,"hex"),a.DataType.personalMessage,r,this.xfp,n,void 0,e),{r:c,s:d,v:u}=await this.requestSignature(n,h,"Scan with your Keystone",'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([c,d,u]).toString("hex")}async signTypedData(e,t){const i=await this._pathFromAddress(e),r=o.v4(),s=a.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(t),"utf-8"),a.DataType.typedData,i,this.xfp,r,void 0,e),{r:n,s:h,v:c}=await this.requestSignature(r,s,"Scan with your Keystone",'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([n,h,c]).toString("hex")}async _pathFromAddress(e){if(this.keyringMode===t.hd){const t=s.toChecksumAddress(e);let i=this.indexes[t];if(void 0===i)for(let e=0;e<1e3;e++)if(t===await this.__addressFromIndex("m",e)){i=e;break}if(void 0===i)throw new Error("Unknown address");return`${this.hdPath}/${this.childrenPath.replace("*",i.toString()).replace(/\*/g,"0")}`}{const t=s.toChecksumAddress(e),i=this.paths[t];if(void 0===i)throw new Error("Unknown address");return i}}}h.type="QR Hardware Wallet Device",exports.BaseKeyring=h;
//# sourceMappingURL=base-eth-keyring.cjs.production.min.js.map
