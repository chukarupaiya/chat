{"version":3,"file":"bc-ur-registry-eth.cjs.production.min.js","sources":["../src/RegistryType.ts","../src/EthSignRequest.ts","../src/EthSignature.ts","../src/ETHNFTItem.ts","../src/utlis.ts","../src/index.ts"],"sourcesContent":["import { RegistryType } from \"@keystonehq/bc-ur-registry\";\n\nexport const ExtendedRegistryTypes = {\n  ETH_SIGN_REQUEST: new RegistryType(\"eth-sign-request\", 401),\n  ETH_SIGNATAURE: new RegistryType(\"eth-signature\", 402),\n  ETH_NFT_ITEM: new RegistryType(\"eth-nft-item\", 403),\n};\n","import {\n  CryptoKeypath,\n  extend,\n  DataItem,\n  PathComponent,\n  RegistryItem,\n  DataItemMap,\n} from \"@keystonehq/bc-ur-registry\";\nimport { ExtendedRegistryTypes } from \"./RegistryType\";\nimport * as uuid from \"uuid\";\n\nconst { decodeToDataItem, RegistryTypes } = extend;\n\nenum Keys {\n  requestId = 1,\n  signData,\n  dataType,\n  chainId,\n  derivationPath,\n  address,\n  origin,\n}\n\nexport enum DataType {\n  transaction = 1,\n  typedData = 2,\n  personalMessage = 3,\n  typedTransaction = 4,\n}\n\ntype signRequestProps = {\n  requestId?: Buffer;\n  signData: Buffer;\n  dataType: DataType;\n  chainId?: number;\n  derivationPath: CryptoKeypath;\n  address?: Buffer;\n  origin?: string;\n};\n\nexport class EthSignRequest extends RegistryItem {\n  private requestId?: Buffer;\n  private signData: Buffer;\n  private dataType: DataType;\n  private chainId?: number;\n  private derivationPath: CryptoKeypath;\n  private address?: Buffer;\n  private origin?: string;\n\n  getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;\n\n  constructor(args: signRequestProps) {\n    super();\n    this.requestId = args.requestId;\n    this.signData = args.signData;\n    this.dataType = args.dataType;\n    this.chainId = args.chainId;\n    this.derivationPath = args.derivationPath;\n    this.address = args.address;\n    this.origin = args.origin;\n  }\n\n  public getRequestId = () => this.requestId;\n  public getSignData = () => this.signData;\n  public getDataType = () => this.dataType;\n  public getChainId = () => this.chainId;\n  public getDerivationPath = () => this.derivationPath.getPath();\n  public getSourceFingerprint = () =>\n    this.derivationPath.getSourceFingerprint();\n  public getSignRequestAddress = () => this.address;\n  public getOrigin = () => this.origin;\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    if (this.requestId) {\n      map[Keys.requestId] = new DataItem(\n        this.requestId,\n        RegistryTypes.UUID.getTag()\n      );\n    }\n    if (this.address) {\n      map[Keys.address] = this.address;\n    }\n    if (this.chainId) {\n      map[Keys.chainId] = this.chainId;\n    }\n\n    if (this.origin) {\n      map[Keys.origin] = this.origin;\n    }\n\n    map[Keys.signData] = this.signData;\n    map[Keys.dataType] = this.dataType;\n\n    const keyPath = this.derivationPath.toDataItem();\n    keyPath.setTag(this.derivationPath.getRegistryType().getTag());\n    map[Keys.derivationPath] = keyPath;\n\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const signData = map[Keys.signData];\n    const dataType = map[Keys.dataType];\n    const derivationPath = CryptoKeypath.fromDataItem(map[Keys.derivationPath]);\n    const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;\n    const address = map[Keys.address] ? map[Keys.address] : undefined;\n    const requestId = map[Keys.requestId]\n      ? map[Keys.requestId].getData()\n      : undefined;\n    const origin = map[Keys.origin] ? map[Keys.origin] : undefined;\n\n    return new EthSignRequest({\n      requestId,\n      signData,\n      dataType,\n      chainId,\n      derivationPath,\n      address,\n      origin,\n    });\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return EthSignRequest.fromDataItem(dataItem);\n  };\n\n  public static constructETHRequest(\n    signData: Buffer,\n    signDataType: DataType,\n    hdPath: string,\n    xfp: string,\n    uuidString?: string,\n    chainId?: number,\n    address?: string,\n    origin?: string\n  ) {\n    const paths = hdPath.replace(/[m|M]\\//, \"\").split(\"/\");\n    const hdpathObject = new CryptoKeypath(\n      paths.map((path) => {\n        const index = parseInt(path.replace(\"'\", \"\"));\n        let isHardened = false;\n        if (path.endsWith(\"'\")) {\n          isHardened = true;\n        }\n        return new PathComponent({ index, hardened: isHardened });\n      }),\n      Buffer.from(xfp, \"hex\")\n    );\n\n    return new EthSignRequest({\n      requestId: uuidString\n        ? Buffer.from(uuid.parse(uuidString) as Uint8Array)\n        : undefined,\n      signData,\n      dataType: signDataType,\n      derivationPath: hdpathObject,\n      chainId,\n      address: address\n        ? Buffer.from(address.replace(\"0x\", \"\"), \"hex\")\n        : undefined,\n      origin: origin || undefined,\n    });\n  }\n}\n","import {\n  extend,\n  DataItem,\n  RegistryItem,\n  DataItemMap,\n} from \"@keystonehq/bc-ur-registry\";\nimport { ExtendedRegistryTypes } from \"./RegistryType\";\n\nconst { RegistryTypes, decodeToDataItem } = extend;\n\nenum Keys {\n  requestId = 1,\n  signature,\n}\n\nexport class ETHSignature extends RegistryItem {\n  private requestId?: Buffer;\n  private signature: Buffer;\n\n  getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATAURE;\n\n  constructor(signature: Buffer, requestId?: Buffer) {\n    super();\n    this.signature = signature;\n    this.requestId = requestId;\n  }\n\n  public getRequestId = () => this.requestId;\n  public getSignature = () => this.signature;\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    if (this.requestId) {\n      map[Keys.requestId] = new DataItem(\n        this.requestId,\n        RegistryTypes.UUID.getTag()\n      );\n    }\n    map[Keys.signature] = this.signature;\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const signature = map[Keys.signature];\n    const requestId = map[Keys.requestId]\n      ? map[Keys.requestId].getData()\n      : undefined;\n\n    return new ETHSignature(signature, requestId);\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return ETHSignature.fromDataItem(dataItem);\n  };\n}\n","import {\n  extend,\n  DataItem,\n  RegistryItem,\n  DataItemMap,\n} from \"@keystonehq/bc-ur-registry\";\nimport { ExtendedRegistryTypes } from \"./RegistryType\";\n\nconst { decodeToDataItem } = extend;\n\nenum Keys {\n  chainId = 1,\n  contractAddress = 2,\n  contractName,\n  name,\n  mediaData,\n}\n\ntype NFTProps = {\n  chainId: number;\n  contractAddress: string;\n  contractName: string;\n  name: string;\n  mediaData: string;\n};\n\nexport class ETHNFTItem extends RegistryItem {\n  private chainId: number;\n  private name: string;\n  private contractAddress: string;\n  private contractName: string;\n  private mediaData: string;\n\n  getRegistryType = () => ExtendedRegistryTypes.ETH_NFT_ITEM;\n\n  constructor(args: NFTProps) {\n    super();\n    this.chainId = args.chainId;\n    this.name = args.name;\n    this.contractAddress = args.contractAddress;\n    this.contractName = args.contractName;\n    this.mediaData = args.mediaData; // remove the data perfix for android usage\n  }\n\n  public getChainId = () => this.chainId;\n  public getName = () => this.name;\n  public getmediaData = () => this.mediaData;\n  public getContractAddress = () => this.contractAddress;\n  public getContractName = () => this.contractName;\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    map[Keys.chainId] = this.chainId;\n    map[Keys.name] = this.name;\n    map[Keys.contractAddress] = this.contractAddress;\n    map[Keys.contractName] = this.contractName;\n    map[Keys.mediaData] = this.mediaData;\n\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const chainId = map[Keys.chainId];\n    const name = map[Keys.name];\n    const mediaData = map[Keys.mediaData];\n    const contractAddress = map[Keys.contractAddress];\n    const contractName = map[Keys.contractName];\n\n    return new ETHNFTItem({\n      chainId,\n      name,\n      contractAddress,\n      contractName,\n      mediaData,\n    });\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return ETHNFTItem.fromDataItem(dataItem);\n  };\n\n  public static constructETHNFTItem(\n    chainId: number,\n    contractAddress: string,\n    contractName: string,\n    name: string,\n    mediaData: string\n  ) {\n    return new ETHNFTItem({\n      chainId,\n      contractAddress,\n      contractName,\n      mediaData,\n      name,\n    });\n  }\n}\n","// @ts-ignore\nimport HDKey from \"hdkey\";\nimport { toChecksumAddress, publicToAddress } from \"ethereumjs-util\";\n\nexport const generateAddressFromXpub = (xpub: string, derivePath: string) => {\n  // @ts-ignore\n  const node = HDKey.fromExtendedKey(xpub);\n  const publicKey = node.derive(derivePath);\n  const address =\n    \"0x\" + publicToAddress(publicKey.publicKey, true).toString(\"hex\");\n  return toChecksumAddress(address);\n};\n\nexport const findHDPathFromAddress = (\n  address: string,\n  xpub: string,\n  numberLimit: number,\n  rootPath: string\n) => {\n  for (let i = 0; i < numberLimit; i++) {\n    const path = `M/0/${i}`;\n    const _address = generateAddressFromXpub(xpub, path);\n    if (address.toLowerCase() == _address.toLowerCase()) {\n      return `${rootPath}/0/${i}`;\n    }\n  }\n  return null;\n};\n","import { patchTags } from \"@keystonehq/bc-ur-registry\";\nimport { ExtendedRegistryTypes } from \"./RegistryType\";\nexport * from \"@keystonehq/bc-ur-registry\";\n\npatchTags(\n  Object.values(ExtendedRegistryTypes)\n    .filter((rt) => !!rt.getTag())\n    .map((rt) => rt.getTag()) as number[]\n);\n\nexport { EthSignRequest, DataType } from \"./EthSignRequest\";\nexport { ETHSignature } from \"./EthSignature\";\nexport { ETHNFTItem } from \"./ETHNFTItem\";\n\nexport { generateAddressFromXpub, findHDPathFromAddress } from \"./utlis\";\n"],"names":["ExtendedRegistryTypes","ETH_SIGN_REQUEST","RegistryType","ETH_SIGNATAURE","ETH_NFT_ITEM","decodeToDataItem","RegistryTypes","extend","Keys","DataType","EthSignRequest","RegistryItem","constructor","args","this","requestId","signData","dataType","chainId","derivationPath","getPath","getSourceFingerprint","address","origin","map","DataItem","UUID","getTag","keyPath","toDataItem","setTag","getRegistryType","signDataType","hdPath","xfp","uuidString","paths","replace","split","hdpathObject","CryptoKeypath","path","index","parseInt","isHardened","endsWith","PathComponent","hardened","Buffer","from","uuid","undefined","dataItem","getData","fromDataItem","_cborPayload","ETHSignature","signature","ETHNFTItem","name","mediaData","contractAddress","contractName","generateAddressFromXpub","xpub","derivePath","publicKey","HDKey","fromExtendedKey","derive","publicToAddress","toString","toChecksumAddress","patchTags","Object","values","filter","rt","numberLimit","rootPath","i","_address","toLowerCase"],"mappings":"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"}