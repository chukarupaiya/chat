"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSnapPermissionName = exports.SNAP_PREFIX = exports.getSnapPrefix = exports.isValidSnapVersionRange = exports.resolveVersion = exports.stripDotSlash = exports.validateSnapShasum = exports.getTargetVersion = exports.satifiesVersionRange = exports.gtVersion = exports.validateNpmSnapManifest = exports.validateNpmSnap = exports.ProgrammaticallyFixableSnapError = exports.SnapValidationFailureReason = exports.fetchNpmSnap = exports.getSnapSourceShasum = exports.PROPOSED_NAME_REGEX = exports.DEFAULT_REQUESTED_SNAP_VERSION = exports.DEFAULT_NPM_REGISTRY = exports.LOCALHOST_HOSTNAMES = exports.NpmSnapFileNames = exports.SnapIdPrefixes = void 0;
const crypto_1 = require("crypto");
const utils_1 = require("@metamask/utils");
const concat_stream_1 = __importDefault(require("concat-stream"));
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
const gunzip_maybe_1 = __importDefault(require("gunzip-maybe"));
const pump_1 = __importDefault(require("pump"));
const readable_web_to_node_stream_1 = require("readable-web-to-node-stream");
const semver_1 = require("semver");
const tar_stream_1 = require("tar-stream");
const json_schemas_1 = require("./json-schemas");
var SnapIdPrefixes;
(function (SnapIdPrefixes) {
    SnapIdPrefixes["npm"] = "npm:";
    SnapIdPrefixes["local"] = "local:";
})(SnapIdPrefixes = exports.SnapIdPrefixes || (exports.SnapIdPrefixes = {}));
var NpmSnapFileNames;
(function (NpmSnapFileNames) {
    NpmSnapFileNames["PackageJson"] = "package.json";
    NpmSnapFileNames["Manifest"] = "snap.manifest.json";
})(NpmSnapFileNames = exports.NpmSnapFileNames || (exports.NpmSnapFileNames = {}));
exports.LOCALHOST_HOSTNAMES = new Set(['localhost', '127.0.0.1', '::1']);
exports.DEFAULT_NPM_REGISTRY = 'https://registry.npmjs.org';
exports.DEFAULT_REQUESTED_SNAP_VERSION = '*';
const SVG_MAX_BYTE_SIZE = 100000;
const SVG_MAX_BYTE_SIZE_TEXT = `${Math.floor(SVG_MAX_BYTE_SIZE / 1000)}kb`;
// This RegEx matches valid npm package names (with some exceptions) and space-
// separated alphanumerical words, optionally with dashes and underscores.
// The RegEx consists of two parts. The first part matches space-separated
// words. It is based on the following Stackoverflow answer:
// https://stackoverflow.com/a/34974982
// The second part, after the pipe operator, is the same RegEx used for the
// `name` field of the official package.json JSON Schema, except that we allow
// mixed-case letters. It was originally copied from:
// https://github.com/SchemaStore/schemastore/blob/81a16897c1dabfd98c72242a5fd62eb080ff76d8/src/schemas/json/package.json#L132-L138
exports.PROPOSED_NAME_REGEX = /^(?:[A-Za-z0-9-_]+( [A-Za-z0-9-_]+)*)|(?:(?:@[A-Za-z0-9-*~][A-Za-z0-9-*._~]*\/)?[A-Za-z0-9-~][A-Za-z0-9-._~]*)$/u;
/**
 * Calculates the Base64-econded SHA-256 digest of a Snap source code string.
 *
 * @param sourceCode - The UTF-8 string source code of a Snap.
 * @returns The Base64-encoded SHA-256 digest of the source code.
 */
function getSnapSourceShasum(sourceCode) {
    return (0, crypto_1.createHash)('sha256').update(sourceCode, 'utf8').digest('base64');
}
exports.getSnapSourceShasum = getSnapSourceShasum;
// npm fetch stuff
const ExpectedSnapFiles = ['manifest', 'packageJson', 'sourceCode'];
const SnapFileNameFromKey = {
    manifest: NpmSnapFileNames.Manifest,
    packageJson: NpmSnapFileNames.PackageJson,
    sourceCode: 'source code bundle',
};
/**
 * Fetches a Snap from the public npm registry.
 *
 * @param packageName - The name of the package whose tarball to fetch.
 * @param versionRange - The SemVer range of the package to fetch. The highest
 * version satisfying the range will be fetched.
 * @param registryUrl - The URL of the npm registry to fetch from.
 * @param fetchFunction - The fetch function to use. Defaults to the global
 * {@link fetch}. Useful for Node.js compatibility.
 * @returns A tuple of the Snap manifest object and the Snap source code.
 */
async function fetchNpmSnap(packageName, versionRange, registryUrl = exports.DEFAULT_NPM_REGISTRY, fetchFunction = fetch) {
    const [tarballResponse, actualVersion] = await fetchNpmTarball(packageName, versionRange, registryUrl, fetchFunction);
    // Extract the tarball and get the necessary files from it.
    const snapFiles = {};
    await new Promise((resolve, reject) => {
        (0, pump_1.default)(getNodeStream(tarballResponse), 
        // The "gz" in "tgz" stands for "gzip". The tarball needs to be decompressed
        // before we can actually grab any files from it.
        (0, gunzip_maybe_1.default)(), createTarballExtractionStream(snapFiles), (error) => {
            error ? reject(error) : resolve();
        });
    });
    // At this point, the necessary files will have been added to the snapFiles
    // object if they exist.
    return validateNpmSnap(snapFiles, `npm Snap "${packageName}@${actualVersion}" validation error: `);
}
exports.fetchNpmSnap = fetchNpmSnap;
/**
 * Snap validation failure reason codes that are programmatically fixable
 * if validation occurs during development.
 */
var SnapValidationFailureReason;
(function (SnapValidationFailureReason) {
    SnapValidationFailureReason["NameMismatch"] = "\"name\" field mismatch";
    SnapValidationFailureReason["VersionMismatch"] = "\"version\" field mismatch";
    SnapValidationFailureReason["RepositoryMismatch"] = "\"repository\" field mismatch";
    SnapValidationFailureReason["ShasumMismatch"] = "\"shasum\" field mismatch";
})(SnapValidationFailureReason = exports.SnapValidationFailureReason || (exports.SnapValidationFailureReason = {}));
/**
 * An error indicating that a Snap validation failure is programmatically
 * fixable during development.
 */
class ProgrammaticallyFixableSnapError extends Error {
    constructor(message, reason) {
        super(message);
        this.reason = reason;
    }
}
exports.ProgrammaticallyFixableSnapError = ProgrammaticallyFixableSnapError;
/**
 * Validates the files extracted from an npm Snap package tarball by ensuring
 * that they're non-empty and that the Json files match their respective schemas
 * and the Snaps publishing specification.
 *
 * @param snapFiles - The object containing the expected Snap file contents,
 * if any.
 * @param errorPrefix - The prefix of the error message.
 * @returns A tuple of the Snap manifest object and the Snap source code.
 */
function validateNpmSnap(snapFiles, errorPrefix) {
    ExpectedSnapFiles.forEach((key) => {
        if (!snapFiles[key]) {
            throw new Error(`${errorPrefix}Missing file "${SnapFileNameFromKey[key]}".`);
        }
    });
    // Typecast: We are assured that the required files exist if we get here.
    const { manifest, packageJson, sourceCode, svgIcon } = snapFiles;
    try {
        (0, json_schemas_1.validateSnapJsonFile)(NpmSnapFileNames.Manifest, manifest);
    }
    catch (error) {
        throw new Error(`${errorPrefix}"${NpmSnapFileNames.Manifest}" is invalid:\n${error.message}`);
    }
    const validatedManifest = manifest;
    const { iconPath } = validatedManifest.source.location.npm;
    if (iconPath && !svgIcon) {
        throw new Error(`${errorPrefix}Missing file "${iconPath}".`);
    }
    try {
        (0, json_schemas_1.validateSnapJsonFile)(NpmSnapFileNames.PackageJson, packageJson);
    }
    catch (error) {
        throw new Error(`${errorPrefix}"${NpmSnapFileNames.PackageJson}" is invalid:\n${error.message}`);
    }
    const validatedPackageJson = packageJson;
    validateNpmSnapManifest({
        manifest: validatedManifest,
        packageJson: validatedPackageJson,
        sourceCode,
    }, errorPrefix);
    if (svgIcon) {
        if (Buffer.byteLength(svgIcon, 'utf8') > SVG_MAX_BYTE_SIZE) {
            throw new Error(`${errorPrefix}The specified SVG icon exceeds the maximum size of ${SVG_MAX_BYTE_SIZE_TEXT}.`);
        }
    }
    return {
        manifest: validatedManifest,
        packageJson: validatedPackageJson,
        sourceCode,
        svgIcon,
    };
}
exports.validateNpmSnap = validateNpmSnap;
/**
 * Validates the fields of an npm Snap manifest that has already passed JSON
 * Schema validation.
 *
 * @param snapFiles - The relevant snap files to validate.
 * @param snapFiles.manifest - The npm Snap manifest to validate.
 * @param snapFiles.packageJson - The npm Snap's `package.json`.
 * @param snapFiles.sourceCode - The Snap's source code.
 * @param errorPrefix - The prefix for error messages.
 * @returns A tuple containing the validated snap manifest, snap source code,
 * and `package.json`.
 */
function validateNpmSnapManifest({ manifest, packageJson, sourceCode }, errorPrefix) {
    const packageJsonName = packageJson.name;
    const packageJsonVersion = packageJson.version;
    const packageJsonRepository = packageJson.repository;
    const manifestPackageName = manifest.source.location.npm.packageName;
    const manifestPackageVersion = manifest.version;
    const manifestRepository = manifest.repository;
    if (packageJsonName !== manifestPackageName) {
        throw new ProgrammaticallyFixableSnapError(`${errorPrefix}"${NpmSnapFileNames.Manifest}" npm package name ("${manifestPackageName}") does not match the "${NpmSnapFileNames.PackageJson}" "name" field ("${packageJsonName}").`, SnapValidationFailureReason.NameMismatch);
    }
    if (packageJsonVersion !== manifestPackageVersion) {
        throw new ProgrammaticallyFixableSnapError(`${errorPrefix}"${NpmSnapFileNames.Manifest}" npm package version ("${manifestPackageVersion}") does not match the "${NpmSnapFileNames.PackageJson}" "version" field ("${packageJsonVersion}").`, SnapValidationFailureReason.VersionMismatch);
    }
    if (
    // The repository may be `undefined` in package.json but can only be defined
    // or `null` in the Snap manifest due to TS@<4.4 issues.
    (packageJsonRepository || manifestRepository) &&
        !(0, fast_deep_equal_1.default)(packageJsonRepository, manifestRepository)) {
        throw new ProgrammaticallyFixableSnapError(`${errorPrefix}"${NpmSnapFileNames.Manifest}" "repository" field does not match the "${NpmSnapFileNames.PackageJson}" "repository" field.`, SnapValidationFailureReason.RepositoryMismatch);
    }
    validateSnapShasum(manifest, sourceCode, `${errorPrefix}"${NpmSnapFileNames.Manifest}" "shasum" field does not match computed shasum.`);
    return [manifest, sourceCode, packageJson];
}
exports.validateNpmSnapManifest = validateNpmSnapManifest;
/**
 * Checks whether a SemVer version is greater than another.
 *
 * @param version1 - The left-hand version.
 * @param version2 - The right-hand version.
 * @returns `version1 > version2`.
 */
function gtVersion(version1, version2) {
    return (0, semver_1.gt)(version1, version2, { includePrerelease: true });
}
exports.gtVersion = gtVersion;
/**
 * Returns whether a SemVer version satisfies a SemVer range.
 *
 * @param version - The SemVer version to check.
 * @param versionRange - The SemVer version range to check against.
 * @returns Whether the version satisfied the version range.
 */
function satifiesVersionRange(version, versionRange) {
    return (0, semver_1.satisfies)(version, versionRange, {
        includePrerelease: true,
    });
}
exports.satifiesVersionRange = satifiesVersionRange;
/**
 * Return the highest version in the list that satisfies the range, or `null` if
 * none of them do. For the satisfaction check, pre-release versions will only
 * be checked if no satisfactory non-prerelease version is found first.
 *
 * @param versions - The list of version to check.
 * @param versionRange - The SemVer version range to check against.
 * @returns The highest version in the list that satisfies the range,
 * or `null` if none of them do.
 */
function getTargetVersion(versions, versionRange) {
    const maxSatisfyingNonPreRelease = (0, semver_1.maxSatisfying)(versions, versionRange);
    // By default don't use pre-release versions
    if (maxSatisfyingNonPreRelease) {
        return maxSatisfyingNonPreRelease;
    }
    // If no satisfying release version is found by default, try pre-release versions
    return (0, semver_1.maxSatisfying)(versions, versionRange, {
        includePrerelease: true,
    });
}
exports.getTargetVersion = getTargetVersion;
/**
 * Fetches the tarball (`.tgz` file) of the specified package and version from
 * the public npm registry. Throws an error if fetching fails.
 *
 * @param packageName - The name of the package whose tarball to fetch.
 * @param versionRange - The SemVer range of the package to fetch. The highest
 * version satisfying the range will be fetched.
 * @param registryUrl - The URL of the npm registry to fetch the tarball from.
 * @param fetchFunction - The fetch function to use. Defaults to the global
 * {@link fetch}. Useful for Node.js compatibility.
 * @returns A tuple of the {@link Response} for the package tarball and the
 * actual version of the package.
 */
async function fetchNpmTarball(packageName, versionRange, registryUrl = exports.DEFAULT_NPM_REGISTRY, fetchFunction = fetch) {
    var _a, _b, _c, _d;
    const packageMetadata = await (await fetchFunction(new URL(packageName, registryUrl).toString())).json();
    if (!(0, utils_1.isObject)(packageMetadata)) {
        throw new Error(`Failed to fetch package "${packageName}" metadata from npm.`);
    }
    const targetVersion = getTargetVersion(Object.keys((_a = packageMetadata === null || packageMetadata === void 0 ? void 0 : packageMetadata.versions) !== null && _a !== void 0 ? _a : {}), versionRange);
    if (targetVersion === null) {
        throw new Error(`Failed to find a matching version in npm metadata for package "${packageName}" and requested semver range "${versionRange}"`);
    }
    const tarballUrlString = (_d = (_c = (_b = packageMetadata.versions) === null || _b === void 0 ? void 0 : _b[targetVersion]) === null || _c === void 0 ? void 0 : _c.dist) === null || _d === void 0 ? void 0 : _d.tarball;
    if (!isValidUrl(tarballUrlString) || !tarballUrlString.endsWith('.tgz')) {
        throw new Error(`Failed to find valid tarball URL in npm metadata for package "${packageName}".`);
    }
    // Override the tarball hostname/protocol with registryUrl hostname/protocol
    const newRegistryUrl = new URL(registryUrl);
    const newTarballUrl = new URL(tarballUrlString);
    newTarballUrl.hostname = newRegistryUrl.hostname;
    newTarballUrl.protocol = newRegistryUrl.protocol;
    // Perform a raw fetch because we want the Response object itself.
    const tarballResponse = await fetchFunction(newTarballUrl.toString());
    if (!tarballResponse.ok) {
        throw new Error(`Failed to fetch tarball for package "${packageName}".`);
    }
    const stream = await tarballResponse.blob().then((blob) => blob.stream());
    return [stream, targetVersion];
}
// The paths of files within npm tarballs appear to always be prefixed with
// "package/".
const NPM_TARBALL_PATH_PREFIX = /^package\//u;
/**
 * Creates a `tar-stream` that will get the necessary files from an npm Snap
 * package tarball (`.tgz` file).
 *
 * @param snapFiles - An object to write target file contents to.
 * @returns The {@link Writable} tarball extraction stream.
 */
function createTarballExtractionStream(snapFiles) {
    // `tar-stream` is pretty old-school, so we create it first and then
    // instrument it by adding event listeners.
    const extractStream = (0, tar_stream_1.extract)();
    // `tar-stream` reads every file in the tarball serially. We already know
    // where to look for package.json and the Snap manifest, but we don't know
    // where the source code is. Therefore, we cache the contents of each .js
    // file in the tarball and pick out the correct one when the stream has ended.
    const jsFileCache = new Map();
    // "entry" is fired for every discreet entity in the tarball. This includes
    // files and folders.
    extractStream.on('entry', (header, entryStream, next) => {
        const { name: headerName, type: headerType } = header;
        if (headerType === 'file') {
            // The name is a path if the header type is "file".
            const filePath = headerName.replace(NPM_TARBALL_PATH_PREFIX, '');
            // Note the use of `concat-stream` since the data for each file may be
            // chunked.
            if (filePath === NpmSnapFileNames.PackageJson) {
                return entryStream.pipe((0, concat_stream_1.default)((data) => {
                    try {
                        snapFiles.packageJson = JSON.parse(data.toString());
                    }
                    catch (_error) {
                        return extractStream.destroy(new Error(`Failed to parse "${NpmSnapFileNames.PackageJson}".`));
                    }
                    return next();
                }));
            }
            else if (filePath === NpmSnapFileNames.Manifest) {
                return entryStream.pipe((0, concat_stream_1.default)((data) => {
                    try {
                        snapFiles.manifest = JSON.parse(data.toString());
                    }
                    catch (_error) {
                        return extractStream.destroy(new Error(`Failed to parse "${NpmSnapFileNames.Manifest}".`));
                    }
                    return next();
                }));
            }
            else if (/\w+\.(?:js|svg)$/u.test(filePath)) {
                return entryStream.pipe((0, concat_stream_1.default)((data) => {
                    jsFileCache.set(filePath, data);
                    return next();
                }));
            }
        }
        // If we get here, the entry is not a file, and we want to ignore. The entry
        // stream must be drained, or the extractStream will stop reading. This is
        // effectively a no-op for the current entry.
        entryStream.on('end', () => next());
        return entryStream.resume();
    });
    // Once we've read the entire tarball, attempt to grab the bundle file
    // contents from the .js file cache.
    extractStream.once('finish', () => {
        var _a, _b, _c, _d, _e;
        if ((0, utils_1.isObject)(snapFiles.manifest)) {
            /* istanbul ignore next: optional chaining */
            const { filePath: _bundlePath, iconPath: _iconPath } = (_c = (_b = (_a = snapFiles.manifest.source) === null || _a === void 0 ? void 0 : _a.location) === null || _b === void 0 ? void 0 : _b.npm) !== null && _c !== void 0 ? _c : {};
            const bundlePath = stripDotSlash(_bundlePath);
            const iconPath = stripDotSlash(_iconPath);
            if (bundlePath) {
                snapFiles.sourceCode = (_d = jsFileCache.get(bundlePath)) === null || _d === void 0 ? void 0 : _d.toString('utf8');
            }
            if (typeof iconPath === 'string' && iconPath.endsWith('.svg')) {
                snapFiles.svgIcon = (_e = jsFileCache.get(iconPath)) === null || _e === void 0 ? void 0 : _e.toString('utf8');
            }
        }
        jsFileCache.clear();
    });
    return extractStream;
}
/**
 * Checks whether the `source.shasum` property of a Snap manifest matches the
 * shasum of a snap source code string.
 *
 * @param manifest - The manifest whose shasum to validate.
 * @param sourceCode - The source code of the snap.
 * @param errorMessage - The error message to throw if validation fails.
 */
function validateSnapShasum(manifest, sourceCode, errorMessage = 'Invalid Snap manifest: manifest shasum does not match computed shasum.') {
    if (manifest.source.shasum !== getSnapSourceShasum(sourceCode)) {
        throw new ProgrammaticallyFixableSnapError(errorMessage, SnapValidationFailureReason.ShasumMismatch);
    }
}
exports.validateSnapShasum = validateSnapShasum;
/**
 * Converts a {@link ReadableStream} to a Node.js {@link Readable}
 * stream. Returns the stream directly if it is already a Node.js stream.
 * We can't use the native Web {@link ReadableStream} directly because the
 * other stream libraries we use expect Node.js streams.
 *
 * @param stream - The stream to convert.
 * @returns The given stream as a Node.js Readable stream.
 */
function getNodeStream(stream) {
    if (typeof stream.getReader !== 'function') {
        return stream;
    }
    return new readable_web_to_node_stream_1.ReadableWebToNodeStream(stream);
}
/**
 * Checks whether a URL is valid.
 *
 * @param maybeUrl - The string to check.
 * @returns Whether the specified string is a valid URL.
 */
function isValidUrl(maybeUrl) {
    try {
        return Boolean(new URL(maybeUrl));
    }
    catch (_error) {
        return false;
    }
}
/**
 * Strips the leading `./` from a string, or does nothing if no string is
 * provided.
 *
 * @param pathString - The path string to normalize.
 * @returns The specified path without a `./` prefix, or `undefined` if no
 * string was provided.
 */
function stripDotSlash(pathString) {
    return pathString === null || pathString === void 0 ? void 0 : pathString.replace(/^\.\//u, '');
}
exports.stripDotSlash = stripDotSlash;
/**
 * Parse a version received by some subject attempting to access a snap.
 *
 * @param version - The received version value.
 * @returns `*` if the version is `undefined` or `latest", otherwise returns
 * the specified version.
 */
function resolveVersion(version) {
    if (version === undefined || version === 'latest') {
        return exports.DEFAULT_REQUESTED_SNAP_VERSION;
    }
    return version;
}
exports.resolveVersion = resolveVersion;
/**
 * Checks whether a SemVer version range is valid.
 *
 * @param versionRange - A potential version range.
 * @returns `true` if the version range is valid, and `false` otherwise.
 */
function isValidSnapVersionRange(versionRange) {
    return Boolean(typeof versionRange === 'string' &&
        (0, semver_1.validRange)(versionRange, { includePrerelease: true }) !== null);
}
exports.isValidSnapVersionRange = isValidSnapVersionRange;
/**
 * Extracts the snap prefix from a snap ID.
 *
 * @param snapId - The snap ID to extract the prefix from.
 * @returns The snap prefix from a snap id, e.g. `npm:`.
 */
function getSnapPrefix(snapId) {
    const prefix = Object.values(SnapIdPrefixes).find((p) => snapId.startsWith(p));
    if (prefix !== undefined) {
        return prefix;
    }
    throw new Error(`Invalid or no prefix found for "${snapId}"`);
}
exports.getSnapPrefix = getSnapPrefix;
exports.SNAP_PREFIX = 'wallet_snap_';
/**
 * Computes the permission name of a snap from its snap ID.
 *
 * @param snapId - The snap ID.
 * @returns The permission name corresponding to the given snap ID.
 */
function getSnapPermissionName(snapId) {
    return exports.SNAP_PREFIX + snapId;
}
exports.getSnapPermissionName = getSnapPermissionName;
//# sourceMappingURL=utils.js.map