import { Camelize, Operation, DateInput, ResponseAdapter } from '@moralisweb3/common-core';
import { SolAddressish, SolNetworkish } from '@moralisweb3/common-sol-utils';
import { operations } from '../openapi';
type OperationId = 'requestChallengeSolana';
type BodyParams = operations[OperationId]['requestBody']['content']['application/json'];
type RequestParams = BodyParams;
type SuccessResponse = operations[OperationId]['responses']['201']['content']['application/json'];
export interface RequestChallengeSolanaRequest extends Camelize<Omit<RequestParams, 'address' | 'network' | 'expirationTime' | 'notBefore'>> {
    address: SolAddressish;
    network: SolNetworkish;
    expirationTime?: DateInput;
    notBefore?: DateInput;
}
export type RequestChallengeSolanaJSONRequest = ReturnType<typeof serializeRequest>;
export type RequestChallengeSolanaJSONResponse = SuccessResponse;
export type RequestChallengeSolanaResponse = ReturnType<typeof deserializeResponse>;
export interface RequestChallengeSolanaResponseAdapter extends ResponseAdapter<RequestChallengeSolanaResponse, RequestChallengeSolanaJSONResponse> {
}
/** The back channel challenge containing the id to store on the api and the message to be signed by the user */
export declare const requestChallengeSolanaOperation: Operation<RequestChallengeSolanaRequest, RequestChallengeSolanaJSONRequest, RequestChallengeSolanaResponse, RequestChallengeSolanaJSONResponse>;
declare function deserializeResponse(jsonResponse: RequestChallengeSolanaJSONResponse): {
    id: string;
    profileId: string;
    message: string;
};
declare function serializeRequest(request: RequestChallengeSolanaRequest): {
    domain: string;
    network: "mainnet" | "devnet";
    address: string;
    statement: string | undefined;
    uri: string;
    expirationTime: DateInput | undefined;
    notBefore: DateInput | undefined;
    resources: string[] | undefined;
    timeout: number;
};
export {};
//# sourceMappingURL=requestChallengeSolanaOperation.d.ts.map