"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmStreamResultParser = void 0;
var common_evm_utils_1 = require("@moralisweb3/common-evm-utils");
var StreamErc1155Approval_1 = require("../StreamErc1155Approval/StreamErc1155Approval");
var StreamErc20Approval_1 = require("../StreamErc20Approval/StreamErc20Approval");
var StreamErc20Transfer_1 = require("../StreamErc20Transfer/StreamErc20Transfer");
var StreamErc721Approval_1 = require("../StreamErc721Approval/StreamErc721Approval");
var StreamEvmInternalTransaction_1 = require("../StreamEvmInternalTransaction/StreamEvmInternalTransaction");
var StreamEvmNftTransfer_1 = require("../StreamEvmNftTransfer/StreamEvmNftTransfer");
var StreamEvmTransaction_1 = require("../StreamEvmTransaction/StreamEvmTransaction");
var StreamEvmTransactionLog_1 = require("../StreamEvmTransactionLog/StreamEvmTransactionLog");
var StreamNativeBalance_1 = require("../StreamNativeBalance");
var EvmStreamResultParser = /** @class */ (function () {
    function EvmStreamResultParser() {
    }
    EvmStreamResultParser.parseChainId = function (value, core) {
        // Only needed for the initial test-response where we get an empty string as chain
        return value === '' ? common_evm_utils_1.EvmChain.ETHEREUM : common_evm_utils_1.EvmChain.create(value, core);
    };
    EvmStreamResultParser.parseErc20Transfers = function (value, chain) {
        return value.map(function (transfer) {
            return StreamErc20Transfer_1.StreamErc20Transfer.create(__assign({ chain: chain }, transfer));
        });
    };
    EvmStreamResultParser.parseErc20Approvals = function (value, chain) {
        return value.map(function (approval) {
            return StreamErc20Approval_1.StreamErc20Approval.create(__assign({ chain: chain }, approval));
        });
    };
    EvmStreamResultParser.parseNftTransfers = function (value, chain) {
        return value.map(function (transfer) {
            return StreamEvmNftTransfer_1.StreamEvmNftTransfer.create(__assign({ chain: chain }, transfer));
        });
    };
    EvmStreamResultParser.parseNftApprovals = function (value, chain) {
        return {
            ERC721: value.ERC721.map(function (approval) {
                return StreamErc721Approval_1.StreamErc721Approval.create(__assign({ chain: chain }, approval));
            }),
            ERC1155: value.ERC1155.map(function (approval) {
                return StreamErc1155Approval_1.StreamErc1155Approval.create(__assign({ chain: chain }, approval));
            }),
        };
    };
    EvmStreamResultParser.parseBlock = function (value, chain) {
        if (value.number === '') {
            return common_evm_utils_1.EvmSimpleBlock.create({
                chain: chain,
                number: 0,
                hash: '',
                timestamp: '0',
            });
        }
        return common_evm_utils_1.EvmSimpleBlock.create(__assign({ chain: chain }, value));
    };
    EvmStreamResultParser.parseLogs = function (value, chain) {
        return value.map(function (log) {
            return StreamEvmTransactionLog_1.StreamEvmTransactionLog.create(__assign({ chain: chain }, log));
        });
    };
    EvmStreamResultParser.parseTransactions = function (value, chain) {
        return value.map(function (transaction) {
            return StreamEvmTransaction_1.StreamEvmTransaction.create(__assign({ chain: chain }, transaction));
        });
    };
    EvmStreamResultParser.parseInternalTransactions = function (value, chain) {
        return value.map(function (transaction) {
            return StreamEvmInternalTransaction_1.StreamEvmInternalTransaction.create(__assign({ chain: chain }, transaction));
        });
    };
    EvmStreamResultParser.parseNativeBalances = function (value) {
        return value.map(function (nativeBalance) { return StreamNativeBalance_1.StreamNativeBalance.create(nativeBalance); });
    };
    var _a;
    _a = EvmStreamResultParser;
    EvmStreamResultParser.parse = function (value, core) {
        var chain = _a.parseChainId(value.chainId, core);
        return {
            chain: chain,
            erc20Transfers: _a.parseErc20Transfers(value.erc20Transfers, chain),
            erc20Approvals: _a.parseErc20Approvals(value.erc20Approvals, chain),
            nftTransfers: _a.parseNftTransfers(value.nftTransfers, chain),
            /**
             * @deprecated Will be removed. Use nftTokenApprovals
             */
            nftApprovals: _a.parseNftApprovals(value.nftApprovals, chain),
            block: _a.parseBlock(value.block, chain),
            logs: _a.parseLogs(value.logs, chain),
            txs: _a.parseTransactions(value.txs, chain),
            txsInternal: _a.parseInternalTransactions(value.txsInternal, chain),
            abi: value.abi,
            retries: value.retries,
            confirmed: value.confirmed,
            streamId: value.streamId,
            tag: value.tag,
            nativeBalances: _a.parseNativeBalances(value.nativeBalances),
        };
    };
    return EvmStreamResultParser;
}());
exports.EvmStreamResultParser = EvmStreamResultParser;
//# sourceMappingURL=EvmStreamResultParser.js.map