{"version":3,"file":"SubscribeBlockTracker.js","sourceRoot":"","sources":["../src/SubscribeBlockTracker.ts"],"names":[],"mappings":";;;;;;AAAA,4EAAmD;AAEnD,yDAAgE;AAEhE,MAAM,cAAc,GAAG,4BAAiB,EAAE,CAAC;AAY3C,MAAa,qBAAsB,SAAQ,mCAAgB;IAMzD,YAAY,OAA2C,EAAE;QACvD,wBAAwB;QACxB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAClB,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAC;SACnE;QAED,+BAA+B;QAC/B,KAAK,CAAC,IAAI,CAAC,CAAC;QACZ,SAAS;QACT,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;IAC9B,CAAC;IAED,KAAK,CAAC,mBAAmB;QACvB,OAAO,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;IACrC,CAAC;IAES,KAAK,CAAC,MAAM;QACpB,IAAI,IAAI,CAAC,eAAe,KAAK,SAAS,IAAI,IAAI,CAAC,eAAe,KAAK,IAAI,EAAE;YACvE,IAAI;gBACF,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAW,CAAC;gBAClE,IAAI,CAAC,eAAe,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE,UAAU,EAAE,EAAE,CAAW,CAAC;gBACnF,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC1D,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,CAAC;aACvC;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;aACvB;SACF;IACH,CAAC;IAES,KAAK,CAAC,IAAI;QAClB,IAAI,IAAI,CAAC,eAAe,KAAK,IAAI,IAAI,IAAI,CAAC,eAAe,KAAK,SAAS,EAAE;YACvE,IAAI;gBACF,MAAM,IAAI,CAAC,KAAK,CAAC,iBAAiB,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;gBAC1D,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;aAC7B;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;aACvB;SACF;IACH,CAAC;IAEO,KAAK,CAAC,MAAc,EAAE,GAAG,MAAiB;QAChD,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC;gBACvB,EAAE,EAAE,cAAc,EAAE,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK;aACrD,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;gBACd,IAAI,GAAG,EAAE;oBACP,MAAM,CAAC,GAAG,CAAC,CAAC;iBACb;qBAAM;oBACL,OAAO,CAAE,GAA+B,CAAC,MAAM,CAAC,CAAC;iBAClD;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,cAAc,CAAC,CAAU,EAAE,QAA6D;;QAC9F,IAAI,QAAQ,CAAC,MAAM,KAAK,kBAAkB,IAAI,OAAA,QAAQ,CAAC,MAAM,0CAAE,YAAY,MAAK,IAAI,CAAC,eAAe,EAAE;YACpG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;SACzD;IACH,CAAC;CACF;AAlED,sDAkEC","sourcesContent":["import getCreateRandomId from 'json-rpc-random-id';\nimport { JsonRpcNotification, JsonRpcSuccess } from 'json-rpc-engine';\nimport { BaseBlockTracker, Provider } from './BaseBlockTracker';\n\nconst createRandomId = getCreateRandomId();\n\ninterface SubscribeBlockTrackerArgs {\n  provider: Provider;\n  blockResetDuration?: number;\n}\n\ninterface SubscriptionNotificationParams {\n  subscription: string;\n  result: { number: string };\n}\n\nexport class SubscribeBlockTracker extends BaseBlockTracker {\n\n  private _provider: Provider;\n\n  private _subscriptionId: string | null;\n\n  constructor(opts: Partial<SubscribeBlockTrackerArgs> = {}) {\n    // parse + validate args\n    if (!opts.provider) {\n      throw new Error('SubscribeBlockTracker - no provider specified.');\n    }\n\n    // BaseBlockTracker constructor\n    super(opts);\n    // config\n    this._provider = opts.provider;\n    this._subscriptionId = null;\n  }\n\n  async checkForLatestBlock(): Promise<string> {\n    return await this.getLatestBlock();\n  }\n\n  protected async _start(): Promise<void> {\n    if (this._subscriptionId === undefined || this._subscriptionId === null) {\n      try {\n        const blockNumber = await this._call('eth_blockNumber') as string;\n        this._subscriptionId = await this._call('eth_subscribe', 'newHeads', {}) as string;\n        this._provider.on('data', this._handleSubData.bind(this));\n        this._newPotentialLatest(blockNumber);\n      } catch (e) {\n        this.emit('error', e);\n      }\n    }\n  }\n\n  protected async _end() {\n    if (this._subscriptionId !== null && this._subscriptionId !== undefined) {\n      try {\n        await this._call('eth_unsubscribe', this._subscriptionId);\n        this._subscriptionId = null;\n      } catch (e) {\n        this.emit('error', e);\n      }\n    }\n  }\n\n  private _call(method: string, ...params: unknown[]): Promise<unknown> {\n    return new Promise((resolve, reject) => {\n      this._provider.sendAsync({\n        id: createRandomId(), method, params, jsonrpc: '2.0',\n      }, (err, res) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve((res as JsonRpcSuccess<unknown>).result);\n        }\n      });\n    });\n  }\n\n  private _handleSubData(_: unknown, response: JsonRpcNotification<SubscriptionNotificationParams>): void {\n    if (response.method === 'eth_subscription' && response.params?.subscription === this._subscriptionId) {\n      this._newPotentialLatest(response.params.result.number);\n    }\n  }\n}\n"]}