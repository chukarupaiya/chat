'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var HDKey = _interopDefault(require('hdkey'));
var ethereumjsUtil = require('ethereumjs-util');
var tx = require('@ethereumjs/tx');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');

const keyringType = "QR Hardware Wallet Device";
const pathBase = "m";
const MAX_INDEX = 1000;
const DEFAULT_CHILDREN_PATH = "0/*";
var KEYRING_MODE;

(function (KEYRING_MODE) {
  KEYRING_MODE["hd"] = "hd";
  KEYRING_MODE["pubkey"] = "pubkey";
})(KEYRING_MODE || (KEYRING_MODE = {}));

var KEYRING_ACCOUNT;

(function (KEYRING_ACCOUNT) {
  KEYRING_ACCOUNT["standard"] = "account.standard";
  KEYRING_ACCOUNT["ledger_live"] = "account.ledger_live";
  KEYRING_ACCOUNT["ledger_legacy"] = "account.ledger_legacy";
})(KEYRING_ACCOUNT || (KEYRING_ACCOUNT = {}));

class BaseKeyring {
  constructor(opts) {
    // @ts-ignore
    this.version = 1;

    this.getInteraction = () => {
      throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.");
    };

    this.type = keyringType;

    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {
      const ethSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);
      const requestIdBuffer = ethSignature.getRequestId();
      const signature = ethSignature.getSignature();

      if (requestIdBuffer) {
        const requestId = uuid.stringify(requestIdBuffer);

        if (requestId !== _requestId) {
          throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");
        }
      }

      const r = signature.slice(0, 32);
      const s = signature.slice(32, 64);
      const v = signature.slice(64);
      return {
        r,
        s,
        v
      };
    };

    this.__readCryptoHDKey = cryptoHDKey => {
      var _cryptoHDKey$getOrigi, _cryptoHDKey$getChild;

      const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;
      const xfp = (_cryptoHDKey$getOrigi = cryptoHDKey.getOrigin().getSourceFingerprint()) == null ? void 0 : _cryptoHDKey$getOrigi.toString("hex");
      const childrenPath = ((_cryptoHDKey$getChild = cryptoHDKey.getChildren()) == null ? void 0 : _cryptoHDKey$getChild.getPath()) || DEFAULT_CHILDREN_PATH;
      const name = cryptoHDKey.getName();

      if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.standard) {
        this.keyringAccount = KEYRING_ACCOUNT.standard;
      } else if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_legacy) {
        this.keyringAccount = KEYRING_ACCOUNT.ledger_legacy;
      }

      if (!xfp) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint");
      }

      const xpub = cryptoHDKey.getBip32Key();
      this.xfp = xfp;
      this.xpub = xpub;
      this.hdPath = hdPath;
      this.childrenPath = childrenPath;

      if (name !== undefined && name !== "") {
        this.name = name;
      }

      this.initialized = true;
    };

    this.__readCryptoAccount = cryptoAccount => {
      var _cryptoAccount$getMas, _cryptoAccount$getOut;

      const xfp = (_cryptoAccount$getMas = cryptoAccount.getMasterFingerprint()) == null ? void 0 : _cryptoAccount$getMas.toString("hex");

      if (!xfp) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint");
      }

      this.xfp = xfp;
      this.initialized = true;
      let changed = false;
      const outputs = cryptoAccount.getOutputDescriptors();

      if (!outputs || outputs.length === 0) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-account, no crypto output found");
      }

      if (outputs.length % 5 !== 0) {
        throw new Error("KeystoneError#invalid_data: only support 5x pubkey accounts for now");
      }

      (_cryptoAccount$getOut = cryptoAccount.getOutputDescriptors()) == null ? void 0 : _cryptoAccount$getOut.forEach(od => {
        try {
          const cryptoHDKey = od.getHDKey();

          if (cryptoHDKey) {
            const key = cryptoHDKey.getKey();
            const path = `M/${cryptoHDKey.getOrigin().getPath()}`;
            const address = "0x" + ethereumjsUtil.publicToAddress(key, true).toString("hex");
            this.name = cryptoHDKey.getName();

            if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_live) {
              this.keyringAccount = KEYRING_ACCOUNT.ledger_live;
            }

            if (this.paths[ethereumjsUtil.toChecksumAddress(address)] === undefined) {
              changed = true;
            }

            this.paths[ethereumjsUtil.toChecksumAddress(address)] = path;
          }
        } catch (e) {
          throw new Error(`KeystoneError#invalid_data: ${e}`);
        }
      });
      return changed;
    }; // private __readLedgerLiveAccounts = async () => {
    //     const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();
    //     if (result.getRegistryType() === extend.RegistryTypes.CRYPTO_ACCOUNT) {
    //         const changed = this.__readCryptoAccount(result as CryptoAccount);
    //         if (!changed) {
    //             throw new Error(`#KeystoneError#pubkey_account.no_new_account`);
    //         }
    //     } else {
    //         throw new Error(`KeystoneError#pubkey_account.unexpected_urtype`);
    //     }
    // };


    this.getName = () => {
      return this.name;
    };

    this.setAccountToUnlock = index => {
      this.unlockedAccount = parseInt(index, 10);
    };

    this.__getNormalPage = async increment => {
      this.page += increment;

      if (this.page <= 0) {
        this.page = 1;
      }

      const from = (this.page - 1) * this.perPage;
      const to = from + this.perPage;
      const accounts = [];

      for (let i = from; i < to; i++) {
        const address = await this.__addressFromIndex(pathBase, i);
        accounts.push({
          address,
          balance: null,
          index: i
        });
        this.indexes[ethereumjsUtil.toChecksumAddress(address)] = i;
      }

      return accounts;
    };

    this.__getLedgerLivePage = async increment => {
      const nextPage = this.page + increment;
      const from = (nextPage - 1) * this.perPage;
      const to = from + this.perPage;
      const accounts = [];

      for (let i = from; i < to; i++) {
        const address = await this.__addressFromIndex(pathBase, i);
        accounts.push({
          address,
          balance: null,
          index: i
        });
      }

      this.page += increment;
      return accounts;
    };

    this.__addressFromIndex = async (pb, i) => {
      if (this.keyringMode === KEYRING_MODE.hd) {
        this.checkKeyring();

        if (!this.hdk) {
          // @ts-ignore
          this.hdk = HDKey.fromExtendedKey(this.xpub);
        }

        const childrenPath = this.childrenPath.replace("*", String(i)).replace(/\*/g, "0");
        const dkey = this.hdk.derive(`${pb}/${childrenPath}`);
        const address = "0x" + ethereumjsUtil.publicToAddress(dkey.publicKey, true).toString("hex");
        return ethereumjsUtil.toChecksumAddress(address);
      } else {
        const result = Object.keys(this.paths)[i];

        if (result) {
          return ethereumjsUtil.toChecksumAddress(result);
        } else {
          throw new Error(`KeystoneError#pubkey_account.no_expected_account`);
        }
      }
    }; //common props


    this.page = 0;
    this.perPage = 5;
    this.accounts = [];
    this.currentAccount = 0;
    this.unlockedAccount = 0;
    this.name = "QR Hardware";
    this.keyringMode = KEYRING_MODE.hd;
    this.keyringAccount = KEYRING_ACCOUNT.standard;
    this.initialized = false; //hd props;

    this.xfp = "";
    this.xpub = "";
    this.hdPath = "";
    this.childrenPath = DEFAULT_CHILDREN_PATH;
    this.indexes = {}; //pubkey props;

    this.paths = {};
    this.deserialize(opts);
  } //initial read


  async readKeyring() {
    const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();
    this.syncKeyring(result);
  }

  syncKeyring(data) {
    if (data.getRegistryType().getType() === bcUrRegistryEth.extend.RegistryTypes.CRYPTO_HDKEY.getType()) {
      this.keyringMode = KEYRING_MODE.hd;

      this.__readCryptoHDKey(data);
    } else {
      this.keyringMode = KEYRING_MODE.pubkey;

      this.__readCryptoAccount(data);
    }
  }

  checkKeyring() {
    if (!this.xfp || !this.xpub || !this.hdPath) {
      throw new Error("KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly");
    }
  }

  serialize() {
    return Promise.resolve({
      //common
      initialized: this.initialized,
      accounts: this.accounts,
      currentAccount: this.currentAccount,
      page: this.page,
      perPage: this.perPage,
      keyringAccount: this.keyringAccount,
      keyringMode: this.keyringMode,
      name: this.name,
      version: this.version,
      xfp: this.xfp,
      //hd
      xpub: this.xpub,
      hdPath: this.hdPath,
      childrenPath: this.childrenPath,
      indexes: this.indexes,
      //pubkey
      paths: this.paths
    });
  }

  deserialize(opts) {
    if (opts) {
      //common props;
      this.accounts = opts.accounts;
      this.currentAccount = opts.currentAccount;
      this.page = opts.page;
      this.perPage = opts.perPage;
      this.name = opts.name;
      this.initialized = opts.initialized;
      this.keyringMode = opts.keyringMode || KEYRING_MODE.hd;
      this.keyringAccount = opts.keyringAccount || KEYRING_ACCOUNT.standard;
      this.xfp = opts.xfp; //hd props;

      this.xpub = opts.xpub;
      this.hdPath = opts.hdPath;
      this.indexes = opts.indexes;
      this.paths = opts.paths;
      this.childrenPath = opts.childrenPath || DEFAULT_CHILDREN_PATH;
    }
  }

  setCurrentAccount(index) {
    this.currentAccount = index;
  }

  getCurrentAccount() {
    return this.currentAccount;
  }

  getCurrentAddress() {
    return this.accounts[this.currentAccount];
  }

  async addAccounts(n = 1) {
    const from = this.unlockedAccount;
    const to = from + n;
    const newAccounts = [];

    for (let i = from; i < to; i++) {
      const address = await this.__addressFromIndex(pathBase, i);
      newAccounts.push(address);
      this.page = 0;
      this.unlockedAccount++;
    }

    this.accounts = this.accounts.concat(newAccounts);
    return this.accounts;
  }

  getFirstPage() {
    this.page = 0;
    return this.__getPage(1);
  }

  getNextPage() {
    return this.__getPage(1);
  }

  getPreviousPage() {
    return this.__getPage(-1);
  }

  async __getPage(increment) {
    if (!this.initialized) {
      await this.readKeyring();
    }

    if (this.keyringMode === KEYRING_MODE.hd) {
      return this.__getNormalPage(increment);
    } else {
      return this.__getLedgerLivePage(increment);
    }
  }

  getAccounts() {
    return Promise.resolve(this.accounts);
  }

  removeAccount(address) {
    if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
  } // tx is an instance of the ethereumjs-transaction class.


  static serializeTx(tx) {
    // need use EIP-155
    // @ts-ignore
    tx.v = new ethereumjsUtil.BN(tx.common.chainId()); // @ts-ignore

    tx.r = new ethereumjsUtil.BN(0); // @ts-ignore

    tx.s = new ethereumjsUtil.BN(0);
    return tx.serialize();
  }

  async signTransaction(address, tx$1) {
    const hdPath = await this._pathFromAddress(address);
    const chainId = tx$1.common.chainId();
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(BaseKeyring.serializeTx(tx$1), bcUrRegistryEth.DataType.transaction, hdPath, this.xfp, requestId, chainId);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    const txJson = tx$1.toJSON();
    return tx.Transaction.fromTxData({
      to: txJson["to"],
      gasLimit: txJson["gasLimit"],
      gasPrice: txJson["gasPrice"],
      data: txJson["data"],
      nonce: txJson["nonce"],
      value: txJson["value"],
      r,
      s,
      v
    }, {
      common: tx$1.common
    });
  }

  signMessage(withAccount, data) {
    return this.signPersonalMessage(withAccount, data);
  }

  async signPersonalMessage(withAccount, messageHex) {
    const usignedHex = ethereumjsUtil.stripHexPrefix(messageHex);
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(usignedHex, "hex"), bcUrRegistryEth.DataType.personalMessage, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');
    return "0x" + Buffer.concat([r, s, v]).toString("hex");
  }

  async signTypedData(withAccount, typedData) {
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(typedData), "utf-8"), bcUrRegistryEth.DataType.typedData, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');
    return "0x" + Buffer.concat([r, s, v]).toString("hex");
  }

  async _pathFromAddress(address) {
    if (this.keyringMode === KEYRING_MODE.hd) {
      const checksummedAddress = ethereumjsUtil.toChecksumAddress(address);
      let index = this.indexes[checksummedAddress];

      if (typeof index === "undefined") {
        for (let i = 0; i < MAX_INDEX; i++) {
          if (checksummedAddress === (await this.__addressFromIndex(pathBase, i))) {
            index = i;
            break;
          }
        }
      }

      if (typeof index === "undefined") {
        throw new Error("Unknown address");
      }

      return `${this.hdPath}/${this.childrenPath.replace("*", index.toString()).replace(/\*/g, "0")}`;
    } else {
      const checksummedAddress = ethereumjsUtil.toChecksumAddress(address);
      const path = this.paths[checksummedAddress];

      if (typeof path === "undefined") {
        throw new Error("Unknown address");
      }

      return path;
    }
  }

}
BaseKeyring.type = keyringType;

exports.BaseKeyring = BaseKeyring;
//# sourceMappingURL=base-eth-keyring.cjs.development.js.map
