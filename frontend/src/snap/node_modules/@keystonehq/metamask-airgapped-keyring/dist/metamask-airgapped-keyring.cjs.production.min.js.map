{"version":3,"file":"metamask-airgapped-keyring.cjs.production.min.js","sources":["../src/MetaMaskInteractionProvider.ts","../src/MetaMaskKeyring.ts"],"sourcesContent":["import { InteractionProvider } from \"@keystonehq/base-eth-keyring\";\nimport { EventEmitter } from \"events\";\nimport { ObservableStore } from \"@metamask/obs-store\";\nimport {\n  EthSignRequest,\n  ETHSignature,\n  CryptoHDKey,\n  CryptoAccount,\n} from \"@keystonehq/bc-ur-registry-eth\";\nimport * as uuid from \"uuid\";\n\nexport type IMemState = ObservableStore<{\n  _version: number;\n  sync: {\n    reading: boolean;\n  };\n  sign: {\n    request?: {\n      requestId: string;\n      payload: {\n        type: string;\n        cbor: string;\n      };\n      title?: string;\n      description?: string;\n    };\n  };\n}>;\n\nexport class MetamaskInteractionProvider\n  extends EventEmitter\n  implements InteractionProvider\n{\n  static instance: MetamaskInteractionProvider;\n  public memStore: IMemState;\n  constructor() {\n    super();\n    if (MetamaskInteractionProvider.instance) {\n      return MetamaskInteractionProvider.instance;\n    }\n    this.memStore = new ObservableStore({\n      sync: { reading: false },\n      sign: {},\n      _version: 1,\n    });\n    MetamaskInteractionProvider.instance = this;\n  }\n\n  private cleanSyncListeners = () => {\n    this.removeAllListeners(\"keystone-sync_success-hdkey\");\n    this.removeAllListeners(\"keystone-sync_success-account\");\n    this.removeAllListeners(\"keystone-sync_cancel\");\n  };\n\n  private cleanSignListeners = (requestId: string) => {\n    this.removeAllListeners(`${requestId}-signed`);\n    this.removeAllListeners(`${requestId}-canceled`);\n  };\n\n  readCryptoHDKeyOrCryptoAccount = (): Promise<CryptoHDKey | CryptoAccount> => {\n    return new Promise((resolve, reject) => {\n      this.memStore.updateState({\n        sync: { reading: true },\n      });\n      this.on(\"keystone-sync_success-hdkey\", (cbor: string) => {\n        const cryptoHDKey = CryptoHDKey.fromCBOR(Buffer.from(cbor, \"hex\"));\n        this.resetState();\n        resolve(cryptoHDKey);\n      });\n      this.on(\"keystone-sync_success-account\", (cbor: string) => {\n        const cryptoAccount = CryptoAccount.fromCBOR(Buffer.from(cbor, \"hex\"));\n        this.resetState();\n        resolve(cryptoAccount);\n      });\n      this.on(\"keystone-sync_cancel\", () => {\n        this.resetState();\n        reject(\n          new Error(\n            \"KeystoneError#sync_cancel. Sync process canceled, please retry\"\n          )\n        );\n      });\n    });\n  };\n\n  submitCryptoHDKey = (cbor: string) => {\n    this.emit(\"keystone-sync_success-hdkey\", cbor);\n  };\n\n  submitCryptoAccount = (cbor: string) => {\n    this.emit(\"keystone-sync_success-account\", cbor);\n  };\n\n  cancelSync = () => {\n    this.emit(\"keystone-sync_cancel\");\n  };\n\n  requestSignature = (\n    signRequest: EthSignRequest,\n    requestTitle?: string,\n    requestDescription?: string\n  ): Promise<ETHSignature> => {\n    return new Promise((resolve, reject) => {\n      const ur = signRequest.toUR();\n      const requestIdBuffer = signRequest.getRequestId();\n      const requestId = uuid.stringify(requestIdBuffer);\n      const signPayload = {\n        requestId,\n        payload: {\n          type: ur.type,\n          cbor: ur.cbor.toString(\"hex\"),\n        },\n        title: requestTitle,\n        description: requestDescription,\n      };\n      this.memStore.updateState({\n        sign: {\n          request: signPayload,\n        },\n      });\n\n      this.once(`${requestId}-signed`, (cbor: string) => {\n        const ethSignature = ETHSignature.fromCBOR(Buffer.from(cbor, \"hex\"));\n        this.resetState();\n        resolve(ethSignature);\n      });\n      this.once(`${requestId}-canceled`, () => {\n        this.resetState();\n        reject(\n          new Error(\"KeystoneError#Tx_canceled. Signing canceled, please retry\")\n        );\n      });\n    });\n  };\n\n  submitSignature = (requestId: string, cbor: string) => {\n    this.emit(`${requestId}-signed`, cbor);\n  };\n\n  cancelRequestSignature = () => {\n    const signPayload = this.memStore.getState().sign.request;\n    if (signPayload) {\n      const { requestId } = signPayload;\n      this.memStore.updateState({ sign: {} });\n      this.emit(`${requestId}-canceled`);\n    }\n  };\n\n  public reset = () => {\n    this.cleanSyncListeners();\n    const signPayload = this.memStore.getState().sign.request;\n    if (signPayload) {\n      const { requestId } = signPayload;\n      this.cleanSignListeners(requestId);\n    }\n    this.resetState();\n  };\n\n  private resetState = () => {\n    this.memStore.updateState({\n      sync: {\n        reading: false,\n      },\n      sign: {},\n    });\n  };\n}\n","import { BaseKeyring, StoredKeyring } from \"@keystonehq/base-eth-keyring\";\nimport { MetamaskInteractionProvider } from \"./MetaMaskInteractionProvider\";\nimport {\n  TransactionFactory,\n  Transaction,\n  FeeMarketEIP1559Transaction,\n} from \"@ethereumjs/tx\";\nimport { DataType, EthSignRequest } from \"@keystonehq/bc-ur-registry-eth\";\nimport * as uuid from \"uuid\";\nimport rlp from \"rlp\";\n\nexport class MetaMaskKeyring extends BaseKeyring {\n  static type = BaseKeyring.type;\n  static instance: MetaMaskKeyring;\n  constructor(opts?: StoredKeyring) {\n    super(opts);\n    if (MetaMaskKeyring.instance) {\n      MetaMaskKeyring.instance.deserialize(opts);\n      return MetaMaskKeyring.instance;\n    }\n    MetaMaskKeyring.instance = this;\n  }\n\n  getInteraction = (): MetamaskInteractionProvider => {\n    return new MetamaskInteractionProvider();\n  };\n\n  resetStore = (): void => {\n    this.getInteraction().reset();\n  };\n\n  getMemStore = () => {\n    return this.getInteraction().memStore;\n  };\n\n  async signTransaction(address: string, tx: any): Promise<any> {\n    const dataType =\n      tx.type === 0 ? DataType.transaction : DataType.typedTransaction;\n    let messageToSign;\n    if (tx.type === 0) {\n      messageToSign = rlp.encode((tx as Transaction).getMessageToSign(false));\n    } else {\n      messageToSign = (tx as FeeMarketEIP1559Transaction).getMessageToSign(\n        false\n      );\n    }\n    const hdPath = await this._pathFromAddress(address);\n    const chainId = tx.common.chainId();\n    const requestId = uuid.v4();\n    const ethSignRequest = EthSignRequest.constructETHRequest(\n      messageToSign,\n      dataType,\n      hdPath,\n      this.xfp,\n      requestId,\n      chainId,\n      address\n    );\n    const { r, s, v } = await this.requestSignature(\n      requestId,\n      ethSignRequest,\n      \"Scan with your Keystone\",\n      'After your Keystone has signed the transaction, click on \"Scan Keystone\" to receive the signature'\n    );\n    const txJson = tx.toJSON();\n    txJson.v = v;\n    txJson.s = s;\n    txJson.r = r;\n    txJson.type = tx.type;\n    const transaction = TransactionFactory.fromTxData(txJson, {\n      common: tx.common,\n    });\n    return transaction;\n  }\n\n  removeAccount = (address) => {\n    if (\n      !this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())\n    ) {\n      throw new Error(`Address ${address} not found in this keyring`);\n    }\n    this.accounts = this.accounts.filter(\n      (a) => a.toLowerCase() !== address.toLowerCase()\n    );\n  };\n\n  forgetDevice = () => {\n    //common props\n    this.page = 0;\n    this.perPage = 5;\n    this.accounts = [];\n    this.currentAccount = 0;\n    this.name = \"QR Hardware\";\n    this.initialized = false;\n\n    //hd props;\n    this.xfp = \"\";\n    this.xpub = \"\";\n    this.hdPath = \"\";\n    this.indexes = {};\n    this.hdk = undefined;\n\n    //pubkey props;\n    this.paths = {};\n  };\n\n  submitCryptoHDKey = this.getInteraction().submitCryptoHDKey;\n  submitCryptoAccount = this.getInteraction().submitCryptoAccount;\n  submitSignature = this.getInteraction().submitSignature;\n\n  cancelSync = this.getInteraction().cancelSync;\n  cancelSignRequest = this.getInteraction().cancelRequestSignature;\n}\n"],"names":["MetamaskInteractionProvider","EventEmitter","constructor","removeAllListeners","requestId","Promise","resolve","reject","memStore","updateState","sync","reading","on","cbor","cryptoHDKey","CryptoHDKey","fromCBOR","Buffer","from","resetState","cryptoAccount","CryptoAccount","Error","emit","signRequest","requestTitle","requestDescription","ur","toUR","requestIdBuffer","getRequestId","uuid","signPayload","payload","type","toString","title","description","sign","request","once","ethSignature","ETHSignature","this","getState","cleanSyncListeners","cleanSignListeners","instance","ObservableStore","_version","MetaMaskKeyring","BaseKeyring","opts","getInteraction","reset","address","accounts","map","a","toLowerCase","includes","filter","page","perPage","currentAccount","name","initialized","xfp","xpub","hdPath","indexes","hdk","undefined","paths","submitCryptoHDKey","submitCryptoAccount","submitSignature","cancelSync","cancelRequestSignature","deserialize","tx","dataType","DataType","transaction","typedTransaction","messageToSign","rlp","encode","getMessageToSign","_pathFromAddress","chainId","common","ethSignRequest","EthSignRequest","constructETHRequest","r","s","v","requestSignature","txJson","toJSON","TransactionFactory","fromTxData"],"mappings":"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"}