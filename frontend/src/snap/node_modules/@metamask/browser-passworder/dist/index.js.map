{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";AAMA;;;;;;;GAOG;AACH,SAAS,OAAO,CAAI,QAAgB,EAAE,OAAU;IAC9C,MAAM,IAAI,GAAG,YAAY,EAAE,CAAC;IAE5B,OAAO,eAAe,CAAC,QAAQ,EAAE,IAAI,CAAC;SACnC,IAAI,CAAC,UAAU,kBAAkB;QAChC,OAAO,cAAc,CAAC,kBAAkB,EAAE,OAAO,CAAC,CAAC;IACrD,CAAC,CAAC;SACD,IAAI,CAAC,UAAU,OAAO;QACrB,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC;QACpB,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;IACjC,CAAC,CAAC,CAAC;AACP,CAAC;AAED;;;;;;;GAOG;AACH,SAAS,cAAc,CACrB,GAAc,EACd,OAAU;IAEV,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;IACrC,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAC9C,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC;IACjE,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM;SACxB,OAAO,CACN;QACE,IAAI,EAAE,SAAS;QACf,EAAE,EAAE,MAAM;KACX,EACD,GAAG,EACH,UAAU,CACX;SACA,IAAI,CAAC,UAAU,GAAG;QACjB,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;QACnC,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACzD,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACxD,OAAO;YACL,IAAI,EAAE,QAAQ;YACd,EAAE,EAAE,SAAS;SACd,CAAC;IACJ,CAAC,CAAC,CAAC;AACP,CAAC;AAED;;;;;GAKG;AACH,SAAS,OAAO,CAAI,QAAgB,EAAE,IAAY;IAChD,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IACjC,MAAM,EAAE,IAAI,EAAE,GAAG,OAAO,CAAC;IACzB,OAAO,eAAe,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,IAAI,CAAC,UAAU,GAAG;QACvD,OAAO,cAAc,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;IACtC,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;GAKG;AACH,SAAS,cAAc,CACrB,GAAc,EACd,OAAyB;IAEzB,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC1D,MAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;IACjD,OAAO,MAAM,CAAC,MAAM;SACjB,OAAO,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,GAAG,EAAE,aAAa,CAAC;SAC5D,IAAI,CAAC,UAAU,MAAM;QACpB,MAAM,aAAa,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;QAC7C,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAClE,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;QAC9C,OAAO,YAAY,CAAC;IACtB,CAAC,CAAC;SACD,KAAK,CAAC,UAAU,MAAM;QACrB,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;IACxC,CAAC,CAAC,CAAC;AACP,CAAC;AAED;;;;GAIG;AACH,SAAS,eAAe,CAAC,QAAgB,EAAE,IAAY;IACrD,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;IAClD,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAE/C,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM;SACxB,SAAS,CAAC,KAAK,EAAE,UAAU,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,EAAE,KAAK,EAAE;QACvD,YAAY;QACZ,WAAW;KACZ,CAAC;SACD,IAAI,CAAC,UAAU,GAAG;QACjB,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,CACnC;YACE,IAAI,EAAE,QAAQ;YACd,IAAI,EAAE,UAAU;YAChB,UAAU,EAAE,KAAK;YACjB,IAAI,EAAE,SAAS;SAChB,EACD,GAAG,EACH,EAAE,IAAI,EAAE,SAAS,EAAE,MAAM,EAAE,GAAG,EAAE,EAChC,KAAK,EACL,CAAC,SAAS,EAAE,SAAS,CAAC,CACvB,CAAC;IACJ,CAAC,CAAC,CAAC;AACP,CAAC;AAED;;;;GAIG;AACH,SAAS,0BAA0B,CAAC,GAAW;IAC7C,MAAM,QAAQ,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;IAC/D,MAAM,GAAG,GAAG,IAAI,UAAU,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAChD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;QAC3C,MAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAClC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;KAChC;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAED;;;;GAIG;AACH,SAAS,yBAAyB,CAAC,MAAkB;IACnD,IAAI,MAAM,GAAG,IAAI,CAAC;IAClB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,UAAU,CAAC;IAC/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;QAC5B,MAAM,IAAI,aAAa,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;KACpC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;;GAKG;AACH,SAAS,aAAa,CAAC,GAAW;IAChC,IAAI,GAAG,GAAG,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IAC3B,OAAO,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE;QACrB,GAAG,GAAG,IAAI,GAAG,EAAE,CAAC;KACjB;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAED;;;;GAIG;AACH,SAAS,YAAY,CAAC,SAAS,GAAG,EAAE;IAClC,MAAM,IAAI,GAAG,IAAI,UAAU,CAAC,SAAS,CAAC,CAAC;IACvC,MAAM,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IACpC,kFAAkF;IAClF,oFAAoF;IACpF,kFAAkF;IAClF,uFAAuF;IACvF,2EAA2E;IAC3E,MAAM,UAAU,GAAG,IAAI,CACrB,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,IAA2B,CAAC,CAC7D,CAAC;IACF,OAAO,UAAU,CAAC;AACpB,CAAC;AAED,iBAAS;IACP,6BAA6B;IAC7B,OAAO;IACP,OAAO;IAEP,oCAAoC;IACpC,eAAe;IACf,cAAc;IACd,cAAc;IAEd,gCAAgC;IAChC,yBAAyB;IACzB,0BAA0B;IAE1B,YAAY;CACb,CAAC","sourcesContent":["interface EncryptionResult {\n  data: string;\n  iv: string;\n  salt?: string;\n}\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @param {string} password - password to use for encryption\n * @param {R} dataObj - data to encrypt\n * @returns {Promise<string>} cypher text\n */\nfunction encrypt<R>(password: string, dataObj: R): Promise<string> {\n  const salt = generateSalt();\n\n  return keyFromPassword(password, salt)\n    .then(function (passwordDerivedKey) {\n      return encryptWithKey(passwordDerivedKey, dataObj);\n    })\n    .then(function (payload) {\n      payload.salt = salt;\n      return JSON.stringify(payload);\n    });\n}\n\n/**\n * Encrypts the provided serializable javascript object using the\n * provided CryptoKey and returns an object containing the cypher text and\n * the initialization vector used.\n * @param {CryptoKey} key - CryptoKey to encrypt with\n * @param {R} dataObj - Serializable javascript object to encrypt\n * @returns {EncryptionResult}\n */\nfunction encryptWithKey<R>(\n  key: CryptoKey,\n  dataObj: R,\n): Promise<EncryptionResult> {\n  const data = JSON.stringify(dataObj);\n  const dataBuffer = Buffer.from(data, 'utf-8');\n  const vector = global.crypto.getRandomValues(new Uint8Array(16));\n  return global.crypto.subtle\n    .encrypt(\n      {\n        name: 'AES-GCM',\n        iv: vector,\n      },\n      key,\n      dataBuffer,\n    )\n    .then(function (buf) {\n      const buffer = new Uint8Array(buf);\n      const vectorStr = Buffer.from(vector).toString('base64');\n      const vaultStr = Buffer.from(buffer).toString('base64');\n      return {\n        data: vaultStr,\n        iv: vectorStr,\n      };\n    });\n}\n\n/**\n * Given a password and a cypher text, decrypts the text and returns\n * the resulting value\n * @param {string} password - password to decrypt with\n * @param {string} text - cypher text to decrypt\n */\nfunction decrypt<R>(password: string, text: string): Promise<R> {\n  const payload = JSON.parse(text);\n  const { salt } = payload;\n  return keyFromPassword(password, salt).then(function (key) {\n    return decryptWithKey(key, payload);\n  });\n}\n\n/**\n * Given a CryptoKey and an EncryptionResult object containing the initialization\n * vector (iv) and data to decrypt, return the resulting decrypted value.\n * @param {CryptoKey} key - CryptoKey to decrypt with\n * @param {EncryptionResult} payload - payload returned from an encryption method\n */\nfunction decryptWithKey<R>(\n  key: CryptoKey,\n  payload: EncryptionResult,\n): Promise<R> {\n  const encryptedData = Buffer.from(payload.data, 'base64');\n  const vector = Buffer.from(payload.iv, 'base64');\n  return crypto.subtle\n    .decrypt({ name: 'AES-GCM', iv: vector }, key, encryptedData)\n    .then(function (result) {\n      const decryptedData = new Uint8Array(result);\n      const decryptedStr = Buffer.from(decryptedData).toString('utf-8');\n      const decryptedObj = JSON.parse(decryptedStr);\n      return decryptedObj;\n    })\n    .catch(function (_error) {\n      throw new Error('Incorrect password');\n    });\n}\n\n/**\n * Generate a CryptoKey from a password and random salt\n * @param {string} password - The password to use to generate key\n * @param {string} salt - The salt string to use in key derivation\n */\nfunction keyFromPassword(password: string, salt: string): Promise<CryptoKey> {\n  const passBuffer = Buffer.from(password, 'utf-8');\n  const saltBuffer = Buffer.from(salt, 'base64');\n\n  return global.crypto.subtle\n    .importKey('raw', passBuffer, { name: 'PBKDF2' }, false, [\n      'deriveBits',\n      'deriveKey',\n    ])\n    .then(function (key) {\n      return global.crypto.subtle.deriveKey(\n        {\n          name: 'PBKDF2',\n          salt: saltBuffer,\n          iterations: 10000,\n          hash: 'SHA-256',\n        },\n        key,\n        { name: 'AES-GCM', length: 256 },\n        false,\n        ['encrypt', 'decrypt'],\n      );\n    });\n}\n\n/**\n * Converts a hex string into a buffer.\n * @param {string} str - hex encoded string\n * @returns {Uint8Array}\n */\nfunction serializeBufferFromStorage(str: string): Uint8Array {\n  const stripStr = str.slice(0, 2) === '0x' ? str.slice(2) : str;\n  const buf = new Uint8Array(stripStr.length / 2);\n  for (let i = 0; i < stripStr.length; i += 2) {\n    const seg = stripStr.substr(i, 2);\n    buf[i / 2] = parseInt(seg, 16);\n  }\n  return buf;\n}\n\n/**\n * Converts a buffer into a hex string ready for storage\n * @param {Uint8Array} buffer - Buffer to serialize\n * @returns {string} hex encoded string\n */\nfunction serializeBufferForStorage(buffer: Uint8Array): string {\n  let result = '0x';\n  const len = buffer.length || buffer.byteLength;\n  for (let i = 0; i < len; i++) {\n    result += unprefixedHex(buffer[i]);\n  }\n  return result;\n}\n\n/**\n * Converts a number into hex value, and ensures proper leading 0\n * for single characters strings.\n * @param {number} num - number to convert to string\n * @returns {string} hex string\n */\nfunction unprefixedHex(num: number): string {\n  let hex = num.toString(16);\n  while (hex.length < 2) {\n    hex = `0${hex}`;\n  }\n  return hex;\n}\n\n/**\n * Generates a random string for use as a salt in CryptoKey generation\n * @param {number} byteCount - Number of bytes to generate\n * @returns {string} randomly generated string\n */\nfunction generateSalt(byteCount = 32): string {\n  const view = new Uint8Array(byteCount);\n  global.crypto.getRandomValues(view);\n  // Uint8Array is a fixed length array and thus does not have methods like pop, etc\n  // so TypeScript complains about casting it to an array. Array.from() works here for\n  // getting the proper type, but it results in a functional difference. In order to\n  // cast, you have to first cast view to unknown then cast the unknown value to number[]\n  // TypeScript ftw: double opt in to write potentially type-mismatched code.\n  const b64encoded = btoa(\n    String.fromCharCode.apply(null, view as unknown as number[]),\n  );\n  return b64encoded;\n}\n\nexport = {\n  // Simple encryption methods:\n  encrypt,\n  decrypt,\n\n  // More advanced encryption methods:\n  keyFromPassword,\n  encryptWithKey,\n  decryptWithKey,\n\n  // Buffer <-> Hex string methods\n  serializeBufferForStorage,\n  serializeBufferFromStorage,\n\n  generateSalt,\n};\n"]}