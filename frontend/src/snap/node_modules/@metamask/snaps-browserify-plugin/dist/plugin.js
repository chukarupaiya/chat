"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SnapsBrowserifyTransform_data, _SnapsBrowserifyTransform_options;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapsBrowserifyTransform = void 0;
const stream_1 = require("stream");
const snap_utils_1 = require("@metamask/snap-utils");
/**
 * A transform stream which can be used in the Browserify pipeline. It accepts a
 * string input, which is post-processed and pushed to the output stream.
 */
class SnapsBrowserifyTransform extends stream_1.Transform {
    /**
     * Construct an instance of the transform stream.
     *
     * @param options - The post-processing options.
     * @param options.stripComments - Whether to strip comments. Defaults to `true`.
     * @param options.transformHtmlComments - Whether to transform HTML comments.
     * Defaults to `true`.
     */
    constructor(options = {}) {
        super();
        _SnapsBrowserifyTransform_data.set(this, []);
        _SnapsBrowserifyTransform_options.set(this, void 0);
        __classPrivateFieldSet(this, _SnapsBrowserifyTransform_options, Object.assign({}, options), "f");
    }
    /**
     * Takes a chunk of data and pushes it into an internal array, for later
     * processing.
     *
     * @param chunk - The chunk of data to transform.
     * @param _encoding - The encoding of the chunk.
     * @param callback - The callback to call when the chunk is processed.
     */
    _transform(chunk, _encoding, callback) {
        // Collects all the chunks into an array.
        __classPrivateFieldGet(this, _SnapsBrowserifyTransform_data, "f").push(chunk);
        callback();
    }
    /**
     * Takes the internal array of chunks and processes them. The processed code
     * is pushed to the output stream.
     *
     * @param callback - The callback to call when the stream is finished.
     */
    _flush(callback) {
        // Merges all the chunks into a single string and processes it.
        const code = Buffer.concat(__classPrivateFieldGet(this, _SnapsBrowserifyTransform_data, "f")).toString('utf-8');
        const transformedCode = (0, snap_utils_1.postProcessBundle)(code, __classPrivateFieldGet(this, _SnapsBrowserifyTransform_options, "f"));
        this.push(transformedCode);
        callback();
    }
}
exports.SnapsBrowserifyTransform = SnapsBrowserifyTransform;
_SnapsBrowserifyTransform_data = new WeakMap(), _SnapsBrowserifyTransform_options = new WeakMap();
/**
 * The Browserify plugin function. Can be passed to the Browserify `plugin`
 * function, or used by simply passing the package name to `plugin`.
 *
 * @param browserifyInstance - The Browserify instance.
 * @param options - The plugin options.
 * @param options.stripComments - Whether to strip comments. Defaults to `true`.
 * @param options.transformHtmlComments - Whether to transform HTML comments.
 * Defaults to `true`.
 */
function plugin(browserifyInstance, options) {
    // Pushes the transform stream at the end of Browserify's pipeline. This
    // ensures that the transform is run on the entire bundle.
    browserifyInstance.pipeline.push(new SnapsBrowserifyTransform(options));
}
exports.default = plugin;
//# sourceMappingURL=plugin.js.map