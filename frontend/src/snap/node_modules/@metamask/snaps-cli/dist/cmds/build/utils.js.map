{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/cmds/build/utils.ts"],"names":[],"mappings":";;;AAAA,2BAAoC;AACpC,2CAA8C;AAE9C,6CAAoD;AAUpD;;;;;;;;;;;;;GAaG;AACI,KAAK,UAAU,eAAe,CAAC,EACpC,WAAW,EACX,YAAY,EACZ,GAAG,EACH,IAAI,EACJ,OAAO,GACa;IACpB,IAAI,WAAW,EAAE;QACf,MAAM,IAAA,iBAAU,EAAC,cAAc,EAAE,WAAW,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;KACpE;IAED,IAAI;QACF,MAAM,aAAE,CAAC,SAAS,CAAC,IAAI,EAAE,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAAE,QAAQ,EAAE,CAAC,CAAC;QACnD,OAAO,CAAC,GAAG,CAAC,mBAAmB,GAAG,iBAAiB,IAAI,IAAI,CAAC,CAAC;QAC7D,OAAO,CAAC,IAAI,CAAC,CAAC;KACf;IAAC,OAAO,KAAK,EAAE;QACd,MAAM,IAAA,iBAAU,EAAC,cAAc,EAAE,KAAK,CAAC,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;KAC9D;AACH,CAAC;AAlBD,0CAkBC;AAED;;;;;GAKG;AACH,SAAgB,mBAAmB,CAAC,IAAe;IACjD,MAAM,EAAE,eAAe,EAAE,iBAAiB,EAAE,GAAG,IAAI,CAAC;IACpD,MAAM,eAAe,GAAwB,EAAE,CAAC;IAChD,IAAI,iBAAiB,KAAK,6BAAkB,CAAC,YAAY,EAAE;QACzD,MAAM,SAAS,GAAG,mBAAmB,CAAC,eAA2B,CAAC,CAAC;QACnE,IAAI,SAAS,KAAK,IAAI,EAAE;YACtB,eAAe,CAAC,MAAM,GAAG,CAAC,SAAS,CAAC,CAAC;SACtC;KACF;IACD,OAAO,eAAe,CAAC;AACzB,CAAC;AAVD,kDAUC;AAED;;;;;GAKG;AACH,SAAgB,mBAAmB,CAAC,YAAsB;IACxD,IAAI,MAAM,GAAkB,IAAI,CAAC;IACjC,IAAI,CAAC,YAAY,IAAI,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE;QACvE,OAAO,MAAM,CAAC;KACf;IACD,MAAM,KAAK,GAAa,uBAAuB,CAAC,YAAY,CAAC,CAAC;IAC9D,MAAM,GAAG,oBAAoB,KAAK,CAAC,KAAK,EAAE,EAAE,CAAC;IAC7C,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,MAAM,IAAI,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC;IAChD,MAAM,IAAI,IAAI,CAAC;IACf,OAAO,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;AAC7B,CAAC;AAVD,kDAUC;AAED;;;;;GAKG;AACH,SAAgB,uBAAuB,CAAC,YAAsB;IAC5D,OAAO,YAAY,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE;QACrC,OAAO,UAAU,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;IACpE,CAAC,CAAC,CAAC;AACL,CAAC;AAJD,0DAIC;AAED;;;;;;;;GAQG;AACH,SAAgB,2BAA2B,CAAC,IAAe;IACzD,IACE,IAAI,CAAC,eAAe;QACpB,IAAI,CAAC,iBAAiB,KAAK,6BAAkB,CAAC,YAAY,EAC1D;QACA,MAAM,IAAI,KAAK,CACb,2FAA2F,CAC5F,CAAC;KACH;AACH,CAAC;AATD,kEASC","sourcesContent":["import { promises as fs } from 'fs';\nimport { writeError } from '../../utils/misc';\nimport { YargsArgs } from '../../types/yargs';\nimport { TranspilationModes } from '../../builders';\n\ntype WriteBundleFileArgs = {\n  bundleError: Error;\n  bundleBuffer: Buffer;\n  src: string;\n  dest: string;\n  resolve: (value: boolean) => void;\n};\n\n/**\n * Performs postprocessing on the bundle contents and writes them to disk.\n * Intended to be used in the callback passed to the Browserify `.bundle()`\n * call.\n *\n * @param options - Options bag.\n * @param options.bundleError - Any error received from Browserify.\n * @param options.bundleBuffer - The {@link Buffer} with the bundle contents\n * from Browserify.\n * @param options.src - The source file path.\n * @param options.dest - The destination file path.\n * @param options.resolve - A {@link Promise} resolution function, so that we\n * can use promises and `async`/`await` even though Browserify uses callbacks.\n */\nexport async function writeBundleFile({\n  bundleError,\n  bundleBuffer,\n  src,\n  dest,\n  resolve,\n}: WriteBundleFileArgs) {\n  if (bundleError) {\n    await writeError('Build error:', bundleError.message, bundleError);\n  }\n\n  try {\n    await fs.writeFile(dest, bundleBuffer?.toString());\n    console.log(`Build success: '${src}' bundled as '${dest}'!`);\n    resolve(true);\n  } catch (error) {\n    await writeError('Write error:', error.message, error, dest);\n  }\n}\n\n/**\n * Processes dependencies and updates `argv` with an options object.\n *\n * @param argv - The Yargs arguments object.\n * @returns An object with options that can be passed to Babelify.\n */\nexport function processDependencies(argv: YargsArgs) {\n  const { depsToTranspile, transpilationMode } = argv;\n  const babelifyOptions: Record<string, any> = {};\n  if (transpilationMode === TranspilationModes.localAndDeps) {\n    const regexpStr = getDependencyRegExp(depsToTranspile as string[]);\n    if (regexpStr !== null) {\n      babelifyOptions.ignore = [regexpStr];\n    }\n  }\n  return babelifyOptions;\n}\n\n/**\n * Processes a string of space delimited dependencies into one RegExp string.\n *\n * @param dependencies - An array of dependencies to add to the RegExp.\n * @returns A RegExp object.\n */\nexport function getDependencyRegExp(dependencies: string[]): RegExp | null {\n  let regexp: string | null = null;\n  if (!dependencies || dependencies.includes('.') || !dependencies.length) {\n    return regexp;\n  }\n  const paths: string[] = sanitizeDependencyPaths(dependencies);\n  regexp = `/node_modules/(?!${paths.shift()}`;\n  paths.forEach((path) => (regexp += `|${path}`));\n  regexp += '/)';\n  return RegExp(regexp, 'u');\n}\n\n/**\n * Helper function remove any leading and trailing slashes from dependency list.\n *\n * @param dependencies - An array of dependencies to sanitize.\n * @returns An array of sanitized paths.\n */\nexport function sanitizeDependencyPaths(dependencies: string[]): string[] {\n  return dependencies.map((dependency) => {\n    return dependency.replace(/^[/\\\\]+/u, '').replace(/[/\\\\]+$/u, '');\n  });\n}\n\n/**\n * Check the Yargs argv object, to see if the provided options are valid. The\n * options are invalid if both `depsToTranspile` are provided, and\n * `transpilationMode` is not set to `localAndDeps`.\n *\n * @param argv - The Yargs arguments object.\n * @throws If the `depsToTranspile` is set, and `transpilationMode` is not set\n * to `localAndDeps`.\n */\nexport function processInvalidTranspilation(argv: YargsArgs) {\n  if (\n    argv.depsToTranspile &&\n    argv.transpilationMode !== TranspilationModes.localAndDeps\n  ) {\n    throw new Error(\n      '\"depsToTranspile\" can only be specified if \"transpilationMode\" is set to \"localAndDeps\" .',\n    );\n  }\n}\n"]}