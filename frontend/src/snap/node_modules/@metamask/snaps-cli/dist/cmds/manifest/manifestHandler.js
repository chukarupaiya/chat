"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWritableManifest = exports.manifestHandler = void 0;
const fs_1 = require("fs");
const utils_1 = require("@metamask/snap-controllers/dist/snaps/utils");
const utils_2 = require("../../utils");
const errorPrefix = 'Manifest Error: ';
const ManifestSortOrder = {
    version: 1,
    proposedName: 2,
    description: 2,
    repository: 3,
    source: 4,
    initialPermissions: 5,
    manifestVersion: 6,
};
/**
 * Validates a snap.manifest.json file. Attempts to fix the manifest and write
 * the fixed version to disk if `writeManifest` is true. Throws if validation
 * fails.
 *
 * @param argv - The Yargs `argv` object.
 * @param argv.writeManifest - Whether to write the fixed manifest to disk.
 */
async function manifestHandler({ writeManifest, }) {
    var _a, _b, _c;
    let didUpdate = false;
    let hasWarnings = false;
    const unvalidatedManifest = await readSnapJsonFile(utils_1.NpmSnapFileNames.Manifest);
    const iconPath = unvalidatedManifest && typeof unvalidatedManifest === 'object'
        ? (_c = (_b = (_a = unvalidatedManifest.source) === null || _a === void 0 ? void 0 : _a.location) === null || _b === void 0 ? void 0 : _b.npm) === null || _c === void 0 ? void 0 : _c.iconPath
        : undefined;
    const snapFiles = {
        manifest: unvalidatedManifest,
        packageJson: await readSnapJsonFile(utils_1.NpmSnapFileNames.PackageJson),
        sourceCode: await getSnapSourceCode(unvalidatedManifest),
        svgIcon: iconPath && (await fs_1.promises.readFile(iconPath, 'utf8')),
    };
    let manifest;
    try {
        ({ manifest } = (0, utils_1.validateNpmSnap)(snapFiles, errorPrefix));
    }
    catch (error) {
        if (writeManifest && error instanceof utils_1.ProgrammaticallyFixableSnapError) {
            // If we get here, the files at least have the correct shape.
            const partiallyValidatedFiles = snapFiles;
            let isInvalid = true;
            const maxAttempts = Object.keys(utils_1.SnapValidationFailureReason).length;
            // Attempt to fix all fixable validation failure reasons. All such reasons
            // are enumerated by the SnapValidationFailureReason enum, so we only
            for (let attempts = 1; isInvalid && attempts <= maxAttempts; attempts++) {
                manifest = fixManifest(partiallyValidatedFiles, error);
                try {
                    (0, utils_1.validateNpmSnapManifest)(Object.assign(Object.assign({}, partiallyValidatedFiles), { manifest }), errorPrefix);
                    isInvalid = false;
                }
                catch (nextValidationError) {
                    /* istanbul ignore next: this should be impossible */
                    if (!(nextValidationError instanceof utils_1.ProgrammaticallyFixableSnapError) ||
                        (attempts === maxAttempts && !isInvalid)) {
                        throw new Error(`Internal Error: Failed to fix manifest. This is a bug, please report it. Reason:\n${error.message}`);
                    }
                }
            }
            didUpdate = true;
        }
        else {
            throw error;
        }
    }
    // TypeScript doesn't see that the 'manifest' variable must be of type
    // SnapManifest at this point, so we cast it.
    const validatedManifest = manifest;
    // Check presence of recommended keys
    const recommendedFields = ['repository'];
    const missingRecommendedFields = recommendedFields.filter((key) => !validatedManifest[key]);
    if (missingRecommendedFields.length > 0) {
        logManifestWarning(`Missing recommended package.json properties:\n${missingRecommendedFields.reduce((allMissing, currentField) => {
            return `${allMissing}\t${currentField}\n`;
        }, '')}`);
    }
    // Validation complete, finish work and notify user.
    if (writeManifest) {
        try {
            await fs_1.promises.writeFile(utils_1.NpmSnapFileNames.Manifest, `${JSON.stringify(getWritableManifest(validatedManifest), null, 2)}\n`);
            if (didUpdate) {
                console.log(`Manifest: Updated snap.manifest.json`);
            }
        }
        catch (error) {
            throw new Error(`${errorPrefix}Failed to update snap.manifest.json: ${error.message}`);
        }
    }
    if (hasWarnings) {
        console.log(`Manifest Warning: Validation of snap.manifest.json completed with warnings. See above.`);
    }
    else {
        console.log(`Manifest Success: Validated snap.manifest.json!`);
    }
    /**
     * Logs a manifest warning, if `suppressWarnings` is not enabled.
     *
     * @param message - The message to log.
     */
    function logManifestWarning(message) {
        if (!global.snaps.suppressWarnings) {
            hasWarnings = true;
            console.warn(`Manifest Warning: ${message}`);
        }
    }
}
exports.manifestHandler = manifestHandler;
/**
 * Utility function for reading `package.json` or the Snap manifest file.
 * These are assumed to be in the current working directory.
 *
 * @param snapJsonFileName - The name of the file to read.
 * @returns The parsed JSON file.
 */
async function readSnapJsonFile(snapJsonFileName) {
    try {
        return await (0, utils_2.readJsonFile)(snapJsonFileName);
    }
    catch (error) {
        if (error.code === 'ENOENT') {
            throw new Error(`${errorPrefix}Could not find '${snapJsonFileName}'. Please ensure that ` +
                `you are running the command in the project root directory.`);
        }
        throw new Error(`${errorPrefix}${error.message}`);
    }
}
/**
 * Given an unvalidated Snap manifest, attempts to extract the location of the
 * bundle source file location and read the file.
 *
 * @param manifest - The unvalidated Snap manifest file contents.
 * @returns The contents of the bundle file, if any.
 */
async function getSnapSourceCode(manifest) {
    var _a, _b, _c;
    if (manifest && typeof manifest === 'object' && !Array.isArray(manifest)) {
        /* istanbul ignore next: optional chaining */
        const sourceFilePath = (_c = (_b = (_a = manifest.source) === null || _a === void 0 ? void 0 : _a.location) === null || _b === void 0 ? void 0 : _b.npm) === null || _c === void 0 ? void 0 : _c.filePath;
        try {
            return sourceFilePath
                ? await fs_1.promises.readFile(sourceFilePath, 'utf8')
                : undefined;
        }
        catch (error) {
            throw new Error(`Manifest Error: Failed to read Snap bundle file: ${error.message}`);
        }
    }
    return undefined;
}
/**
 * Given the relevant Snap files (manifest, `package.json`, and bundle) and a
 * Snap manifest validation error, fixes the fault in the manifest that caused
 * the error.
 *
 * @param snapFiles - The contents of all Snap files.
 * @param error - The {@link ProgrammaticallyFixableSnapError} that was thrown.
 * @returns A copy of the manifest file where the cause of the error is fixed.
 */
function fixManifest(snapFiles, error) {
    const { manifest, packageJson, sourceCode } = snapFiles;
    const manifestCopy = (0, utils_2.deepClone)(manifest);
    switch (error.reason) {
        case utils_1.SnapValidationFailureReason.NameMismatch:
            manifestCopy.source.location.npm.packageName = packageJson.name;
            break;
        case utils_1.SnapValidationFailureReason.VersionMismatch:
            manifestCopy.version = packageJson.version;
            break;
        case utils_1.SnapValidationFailureReason.RepositoryMismatch:
            manifestCopy.repository = packageJson.repository
                ? (0, utils_2.deepClone)(packageJson.repository)
                : null;
            break;
        case utils_1.SnapValidationFailureReason.ShasumMismatch:
            manifestCopy.source.shasum = (0, utils_1.getSnapSourceShasum)(sourceCode);
            break;
        /* istanbul ignore next */
        default:
            // eslint-disable-next-line no-case-declarations
            const failureReason = error.reason;
            throw new Error(`Unrecognized validation failure reason: '${failureReason}'`);
    }
    return manifestCopy;
}
/**
 * Sorts the given manifest in our preferred sort order and removes the
 * `repository` field if it is falsy (it may be `null`).
 *
 * @param manifest - The manifest to sort and modify.
 * @returns The disk-ready manifest.
 */
function getWritableManifest(manifest) {
    const { repository } = manifest, remaining = __rest(manifest, ["repository"]);
    return Object.keys(repository ? Object.assign(Object.assign({}, remaining), { repository }) : remaining)
        .sort((a, b) => ManifestSortOrder[a] - ManifestSortOrder[b])
        .reduce((outManifest, key) => {
        outManifest[key] = manifest[key];
        return outManifest;
    }, {});
}
exports.getWritableManifest = getWritableManifest;
//# sourceMappingURL=manifestHandler.js.map