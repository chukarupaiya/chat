{"version":3,"file":"manifestHandler.js","sourceRoot":"","sources":["../../../src/cmds/manifest/manifestHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import { promises as fs } from 'fs';\nimport type { Json, SnapManifest } from '@metamask/snap-controllers';\nimport {\n  NpmSnapFileNames,\n  UnvalidatedSnapFiles,\n  validateNpmSnap,\n  validateNpmSnapManifest,\n  getSnapSourceShasum,\n  ProgrammaticallyFixableSnapError,\n  SnapValidationFailureReason,\n  SnapFiles,\n} from '@metamask/snap-controllers/dist/snaps/utils';\nimport { deepClone, readJsonFile } from '../../utils';\nimport { YargsArgs } from '../../types/yargs';\n\nconst errorPrefix = 'Manifest Error: ';\n\nconst ManifestSortOrder: Record<keyof SnapManifest, number> = {\n  version: 1,\n  proposedName: 2,\n  description: 2,\n  repository: 3,\n  source: 4,\n  initialPermissions: 5,\n  manifestVersion: 6,\n};\n\n/**\n * Validates a snap.manifest.json file. Attempts to fix the manifest and write\n * the fixed version to disk if `writeManifest` is true. Throws if validation\n * fails.\n *\n * @param argv - The Yargs `argv` object.\n * @param argv.writeManifest - Whether to write the fixed manifest to disk.\n */\nexport async function manifestHandler({\n  writeManifest,\n}: YargsArgs): Promise<void> {\n  let didUpdate = false;\n  let hasWarnings = false;\n\n  const unvalidatedManifest = await readSnapJsonFile(NpmSnapFileNames.Manifest);\n\n  const iconPath =\n    unvalidatedManifest && typeof unvalidatedManifest === 'object'\n      ? (unvalidatedManifest as Partial<SnapManifest>).source?.location?.npm\n          ?.iconPath\n      : undefined;\n\n  const snapFiles: UnvalidatedSnapFiles = {\n    manifest: unvalidatedManifest,\n    packageJson: await readSnapJsonFile(NpmSnapFileNames.PackageJson),\n    sourceCode: await getSnapSourceCode(unvalidatedManifest),\n    svgIcon: iconPath && (await fs.readFile(iconPath, 'utf8')),\n  };\n\n  let manifest: SnapManifest | undefined;\n  try {\n    ({ manifest } = validateNpmSnap(snapFiles, errorPrefix));\n  } catch (error) {\n    if (writeManifest && error instanceof ProgrammaticallyFixableSnapError) {\n      // If we get here, the files at least have the correct shape.\n      const partiallyValidatedFiles = snapFiles as SnapFiles;\n\n      let isInvalid = true;\n      const maxAttempts = Object.keys(SnapValidationFailureReason).length;\n\n      // Attempt to fix all fixable validation failure reasons. All such reasons\n      // are enumerated by the SnapValidationFailureReason enum, so we only\n      for (let attempts = 1; isInvalid && attempts <= maxAttempts; attempts++) {\n        manifest = fixManifest(partiallyValidatedFiles, error);\n\n        try {\n          validateNpmSnapManifest(\n            { ...partiallyValidatedFiles, manifest },\n            errorPrefix,\n          );\n\n          isInvalid = false;\n        } catch (nextValidationError) {\n          /* istanbul ignore next: this should be impossible */\n          if (\n            !(\n              nextValidationError instanceof ProgrammaticallyFixableSnapError\n            ) ||\n            (attempts === maxAttempts && !isInvalid)\n          ) {\n            throw new Error(\n              `Internal Error: Failed to fix manifest. This is a bug, please report it. Reason:\\n${error.message}`,\n            );\n          }\n        }\n      }\n\n      didUpdate = true;\n    } else {\n      throw error;\n    }\n  }\n\n  // TypeScript doesn't see that the 'manifest' variable must be of type\n  // SnapManifest at this point, so we cast it.\n  const validatedManifest = manifest as SnapManifest;\n\n  // Check presence of recommended keys\n  const recommendedFields = ['repository'] as const;\n\n  const missingRecommendedFields = recommendedFields.filter(\n    (key) => !validatedManifest[key],\n  );\n\n  if (missingRecommendedFields.length > 0) {\n    logManifestWarning(\n      `Missing recommended package.json properties:\\n${missingRecommendedFields.reduce(\n        (allMissing, currentField) => {\n          return `${allMissing}\\t${currentField}\\n`;\n        },\n        '',\n      )}`,\n    );\n  }\n\n  // Validation complete, finish work and notify user.\n\n  if (writeManifest) {\n    try {\n      await fs.writeFile(\n        NpmSnapFileNames.Manifest,\n        `${JSON.stringify(getWritableManifest(validatedManifest), null, 2)}\\n`,\n      );\n\n      if (didUpdate) {\n        console.log(`Manifest: Updated snap.manifest.json`);\n      }\n    } catch (error) {\n      throw new Error(\n        `${errorPrefix}Failed to update snap.manifest.json: ${error.message}`,\n      );\n    }\n  }\n\n  if (hasWarnings) {\n    console.log(\n      `Manifest Warning: Validation of snap.manifest.json completed with warnings. See above.`,\n    );\n  } else {\n    console.log(`Manifest Success: Validated snap.manifest.json!`);\n  }\n\n  /**\n   * Logs a manifest warning, if `suppressWarnings` is not enabled.\n   *\n   * @param message - The message to log.\n   */\n  function logManifestWarning(message: string) {\n    if (!global.snaps.suppressWarnings) {\n      hasWarnings = true;\n      console.warn(`Manifest Warning: ${message}`);\n    }\n  }\n}\n\n/**\n * Utility function for reading `package.json` or the Snap manifest file.\n * These are assumed to be in the current working directory.\n *\n * @param snapJsonFileName - The name of the file to read.\n * @returns The parsed JSON file.\n */\nasync function readSnapJsonFile(\n  snapJsonFileName: NpmSnapFileNames,\n): Promise<Json> {\n  try {\n    return await readJsonFile(snapJsonFileName);\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      throw new Error(\n        `${errorPrefix}Could not find '${snapJsonFileName}'. Please ensure that ` +\n          `you are running the command in the project root directory.`,\n      );\n    }\n    throw new Error(`${errorPrefix}${error.message}`);\n  }\n}\n\n/**\n * Given an unvalidated Snap manifest, attempts to extract the location of the\n * bundle source file location and read the file.\n *\n * @param manifest - The unvalidated Snap manifest file contents.\n * @returns The contents of the bundle file, if any.\n */\nasync function getSnapSourceCode(manifest: Json): Promise<string | undefined> {\n  if (manifest && typeof manifest === 'object' && !Array.isArray(manifest)) {\n    /* istanbul ignore next: optional chaining */\n    const sourceFilePath = (manifest as Partial<SnapManifest>).source?.location\n      ?.npm?.filePath;\n\n    try {\n      return sourceFilePath\n        ? await fs.readFile(sourceFilePath, 'utf8')\n        : undefined;\n    } catch (error) {\n      throw new Error(\n        `Manifest Error: Failed to read Snap bundle file: ${error.message}`,\n      );\n    }\n  }\n  return undefined;\n}\n\n/**\n * Given the relevant Snap files (manifest, `package.json`, and bundle) and a\n * Snap manifest validation error, fixes the fault in the manifest that caused\n * the error.\n *\n * @param snapFiles - The contents of all Snap files.\n * @param error - The {@link ProgrammaticallyFixableSnapError} that was thrown.\n * @returns A copy of the manifest file where the cause of the error is fixed.\n */\nfunction fixManifest(\n  snapFiles: SnapFiles,\n  error: ProgrammaticallyFixableSnapError,\n): SnapManifest {\n  const { manifest, packageJson, sourceCode } = snapFiles;\n  const manifestCopy = deepClone(manifest);\n\n  switch (error.reason) {\n    case SnapValidationFailureReason.NameMismatch:\n      manifestCopy.source.location.npm.packageName = packageJson.name;\n      break;\n\n    case SnapValidationFailureReason.VersionMismatch:\n      manifestCopy.version = packageJson.version;\n      break;\n\n    case SnapValidationFailureReason.RepositoryMismatch:\n      manifestCopy.repository = packageJson.repository\n        ? deepClone(packageJson.repository)\n        : null;\n      break;\n\n    case SnapValidationFailureReason.ShasumMismatch:\n      manifestCopy.source.shasum = getSnapSourceShasum(sourceCode);\n      break;\n\n    /* istanbul ignore next */\n    default:\n      // eslint-disable-next-line no-case-declarations\n      const failureReason: never = error.reason;\n      throw new Error(\n        `Unrecognized validation failure reason: '${failureReason}'`,\n      );\n  }\n\n  return manifestCopy;\n}\n\n/**\n * Sorts the given manifest in our preferred sort order and removes the\n * `repository` field if it is falsy (it may be `null`).\n *\n * @param manifest - The manifest to sort and modify.\n * @returns The disk-ready manifest.\n */\nexport function getWritableManifest(manifest: SnapManifest): SnapManifest {\n  const { repository, ...remaining } = manifest;\n  return (\n    Object.keys(\n      repository ? { ...remaining, repository } : remaining,\n    ) as (keyof SnapManifest)[]\n  )\n    .sort((a, b) => ManifestSortOrder[a] - ManifestSortOrder[b])\n    .reduce((outManifest, key) => {\n      (outManifest as any)[key] = manifest[key];\n      return outManifest;\n    }, {} as SnapManifest);\n}\n"]}