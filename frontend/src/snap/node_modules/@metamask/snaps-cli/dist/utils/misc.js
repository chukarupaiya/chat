"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.trimPathString = exports.writeError = exports.logWarning = exports.logError = exports.sanitizeInputs = exports.booleanStringToBoolean = exports.setSnapGlobals = exports.CONFIG_FILE = exports.permRequestKeys = exports.deepClone = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const utils_1 = require("@metamask/utils");
const rfdc_1 = __importDefault(require("rfdc"));
exports.deepClone = (0, rfdc_1.default)({ proto: false, circles: false });
exports.permRequestKeys = [
    '@context',
    'id',
    'parentCapability',
    'invoker',
    'date',
    'caveats',
    'proof',
];
exports.CONFIG_FILE = 'snap.config.js';
// CLI arguments whose values are file paths
const pathArguments = new Set([
    'src',
    's',
    'dist',
    'd',
    'bundle',
    'b',
    'root',
    'r',
]);
/**
 * Sets global variable snaps which tracks user settings:
 * watch mode activation, verbose errors messages, and whether to suppress
 * warnings.
 *
 * @param argv - Arguments as an object generated by `yargs`.
 */
function setSnapGlobals(argv) {
    if (['w', 'watch'].includes(argv._[0])) {
        global.snaps.isWatching = true;
    }
    else {
        global.snaps.isWatching = false;
    }
    if ((0, utils_1.hasProperty)(argv, 'verboseErrors')) {
        global.snaps.verboseErrors = booleanStringToBoolean(argv.verboseErrors);
    }
    if ((0, utils_1.hasProperty)(argv, 'suppressWarnings')) {
        global.snaps.suppressWarnings = booleanStringToBoolean(argv.suppressWarnings);
    }
}
exports.setSnapGlobals = setSnapGlobals;
/**
 * Attempts to convert a string to a boolean and throws if the value is invalid.
 *
 * @param value - The value to convert to a boolean.
 * @returns `true` if the value is the string `"true"`, `false` if it is the
 * string `"false"`, the value if it is already a boolean, or an error
 * otherwise.
 */
function booleanStringToBoolean(value) {
    if (typeof value === 'boolean') {
        return value;
    }
    else if (value === 'true') {
        return true;
    }
    else if (value === 'false') {
        return false;
    }
    throw new Error(`Expected a boolean or the strings "true" or "false". Received: "${value}"`);
}
exports.booleanStringToBoolean = booleanStringToBoolean;
/**
 * Sanitizes inputs. Currently normalizes "./" paths to ".".
 * Yargs handles other path normalization as specified in builders.
 *
 * @param argv - Arguments as an object generated by yargs.
 */
function sanitizeInputs(argv) {
    Object.keys(argv).forEach((key) => {
        if (typeof argv[key] === 'string') {
            // Node's path.normalize() does not do this
            if (argv[key] === './') {
                argv[key] = '.';
            }
            if (pathArguments.has(key)) {
                argv[key] = path_1.default.normalize(argv[key]);
            }
        }
    });
}
exports.sanitizeInputs = sanitizeInputs;
/**
 * Logs an error message to console. Logs original error if it exists and
 * the verboseErrors global is true.
 *
 * @param msg - The error message.
 * @param err - The original error.
 */
function logError(msg, err) {
    console.error(msg);
    if (err && global.snaps.verboseErrors) {
        console.error(err);
    }
}
exports.logError = logError;
/**
 * Logs a warning message to console.
 *
 * @param msg - The warning message.
 * @param error - The original error.
 */
function logWarning(msg, error) {
    if (msg && !global.snaps.suppressWarnings) {
        console.warn(msg);
        if (error && global.snaps.verboseErrors) {
            console.error(error);
        }
    }
}
exports.logWarning = logWarning;
/**
 * Logs an error, attempts to unlink the destination file, and kills the
 * process.
 *
 * @param prefix - The message prefix.
 * @param msg - The error message.
 * @param err - The original error.
 * @param destFilePath - The output file path.
 */
async function writeError(prefix, msg, err, destFilePath) {
    let processedPrefix = prefix;
    if (!prefix.endsWith(' ')) {
        processedPrefix += ' ';
    }
    logError(processedPrefix + msg, err);
    try {
        if (destFilePath) {
            await fs_1.promises.unlink(destFilePath);
        }
    }
    catch (unlinkError) {
        logError(`${processedPrefix}Failed to unlink mangled file.`, unlinkError);
    }
    // unless the watcher is active, exit
    if (!global.snaps.isWatching) {
        // TODO(ritave): Remove process exit and change into collapse of functions
        //               https://github.com/MetaMask/snaps-skunkworks/issues/81
        process.exit(1);
    }
}
exports.writeError = writeError;
/**
 * Trims leading and trailing periods "." and forward slashes "/" from the
 * given path string.
 *
 * @param pathString - The path string to trim.
 * @returns The trimmed path string.
 */
function trimPathString(pathString) {
    return pathString.replace(/^[./]+|[./]+$/gu, '');
}
exports.trimPathString = trimPathString;
//# sourceMappingURL=misc.js.map