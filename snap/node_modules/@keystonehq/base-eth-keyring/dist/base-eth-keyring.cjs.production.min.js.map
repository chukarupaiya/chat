{"version":3,"file":"base-eth-keyring.cjs.production.min.js","sources":["../src/BaseKeyring.ts"],"sourcesContent":["import HDKey from \"hdkey\";\nimport {\n  toChecksumAddress,\n  publicToAddress,\n  BN,\n  stripHexPrefix,\n} from \"ethereumjs-util\";\nimport { Transaction } from \"@ethereumjs/tx\";\nimport {\n  CryptoHDKey,\n  DataType,\n  EthSignRequest,\n  extend,\n  CryptoAccount,\n} from \"@keystonehq/bc-ur-registry-eth\";\nimport * as uuid from \"uuid\";\nimport { InteractionProvider } from \"./InteractionProvider\";\n\nconst keyringType = \"QR Hardware Wallet Device\";\nconst pathBase = \"m\";\nconst MAX_INDEX = 1000;\n\nexport type StoredKeyring = {\n  //common props;\n  version: number;\n  initialized: boolean;\n  accounts: string[];\n  currentAccount: number;\n  page: number;\n  perPage: number;\n  name: string;\n  keyringMode?: string;\n  keyringAccount?: string;\n  xfp: string;\n\n  //hd props;\n  xpub: string;\n  hdPath: string;\n  indexes: Record<string, number>;\n  childrenPath: string;\n\n  //pubkey props;\n  paths: Record<string, string>;\n};\n\nexport type PagedAccount = { address: string; balance: any; index: number };\n\nconst DEFAULT_CHILDREN_PATH = \"0/*\";\n\nenum KEYRING_MODE {\n  hd = \"hd\",\n  pubkey = \"pubkey\",\n}\n\nenum KEYRING_ACCOUNT {\n  standard = \"account.standard\",\n  ledger_live = \"account.ledger_live\",\n  ledger_legacy = \"account.ledger_legacy\",\n}\n\nexport class BaseKeyring {\n  // @ts-ignore\n  private version = 1;\n  getInteraction = (): InteractionProvider => {\n    throw new Error(\n      \"KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.\"\n    );\n  };\n  static type = keyringType;\n  protected xfp: string;\n  protected type = keyringType;\n  protected keyringMode: KEYRING_MODE;\n  protected initialized: boolean;\n  protected xpub: string;\n  protected hdPath: string;\n  protected childrenPath: string;\n  protected accounts: string[];\n  protected currentAccount: number;\n  protected page: number;\n  protected perPage: number;\n  protected indexes: Record<string, number>;\n  protected hdk: any;\n  protected name: string;\n  protected paths: Record<string, string>;\n  protected keyringAccount: KEYRING_ACCOUNT;\n\n  private unlockedAccount: number;\n\n  constructor(opts?: StoredKeyring) {\n    //common props\n    this.page = 0;\n    this.perPage = 5;\n    this.accounts = [];\n    this.currentAccount = 0;\n    this.unlockedAccount = 0;\n    this.name = \"QR Hardware\";\n    this.keyringMode = KEYRING_MODE.hd;\n    this.keyringAccount = KEYRING_ACCOUNT.standard;\n    this.initialized = false;\n\n    //hd props;\n    this.xfp = \"\";\n    this.xpub = \"\";\n    this.hdPath = \"\";\n    this.childrenPath = DEFAULT_CHILDREN_PATH;\n    this.indexes = {};\n\n    //pubkey props;\n    this.paths = {};\n\n    this.deserialize(opts);\n  }\n\n  protected requestSignature = async (\n    _requestId: string,\n    signRequest: EthSignRequest,\n    requestTitle?: string,\n    requestDescription?: string\n  ): Promise<{ r: Buffer; s: Buffer; v: Buffer }> => {\n    const ethSignature = await this.getInteraction().requestSignature(\n      signRequest,\n      requestTitle,\n      requestDescription\n    );\n    const requestIdBuffer = ethSignature.getRequestId();\n    const signature = ethSignature.getSignature();\n    if (requestIdBuffer) {\n      const requestId = uuid.stringify(requestIdBuffer);\n      if (requestId !== _requestId) {\n        throw new Error(\n          \"KeystoneError#invalid_data: read signature error: mismatched requestId\"\n        );\n      }\n    }\n    const r = signature.slice(0, 32);\n    const s = signature.slice(32, 64);\n    const v = signature.slice(64);\n    return {\n      r,\n      s,\n      v,\n    };\n  };\n\n  private __readCryptoHDKey = (cryptoHDKey: CryptoHDKey) => {\n    const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;\n    const xfp = cryptoHDKey.getOrigin().getSourceFingerprint()?.toString(\"hex\");\n    const childrenPath =\n      cryptoHDKey.getChildren()?.getPath() || DEFAULT_CHILDREN_PATH;\n    const name = cryptoHDKey.getName();\n    if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.standard) {\n      this.keyringAccount = KEYRING_ACCOUNT.standard;\n    } else if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_legacy) {\n      this.keyringAccount = KEYRING_ACCOUNT.ledger_legacy;\n    }\n    if (!xfp) {\n      throw new Error(\n        \"KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint\"\n      );\n    }\n    const xpub = cryptoHDKey.getBip32Key();\n    this.xfp = xfp;\n    this.xpub = xpub;\n    this.hdPath = hdPath;\n    this.childrenPath = childrenPath;\n    if (name !== undefined && name !== \"\") {\n      this.name = name;\n    }\n    this.initialized = true;\n  };\n\n  private __readCryptoAccount = (cryptoAccount: CryptoAccount): boolean => {\n    const xfp = cryptoAccount.getMasterFingerprint()?.toString(\"hex\");\n    if (!xfp) {\n      throw new Error(\n        \"KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint\"\n      );\n    }\n    this.xfp = xfp;\n    this.initialized = true;\n    let changed = false;\n    const outputs = cryptoAccount.getOutputDescriptors();\n    if (!outputs || outputs.length === 0) {\n      throw new Error(\n        \"KeystoneError#invalid_data: invalid crypto-account, no crypto output found\"\n      );\n    }\n    if (outputs.length % 5 !== 0) {\n      throw new Error(\n        \"KeystoneError#invalid_data: only support 5x pubkey accounts for now\"\n      );\n    }\n    cryptoAccount.getOutputDescriptors()?.forEach((od) => {\n      try {\n        const cryptoHDKey = od.getHDKey();\n        if (cryptoHDKey) {\n          const key = cryptoHDKey.getKey();\n          const path = `M/${cryptoHDKey.getOrigin().getPath()}`;\n          const address = \"0x\" + publicToAddress(key, true).toString(\"hex\");\n          this.name = cryptoHDKey.getName();\n          if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_live) {\n            this.keyringAccount = KEYRING_ACCOUNT.ledger_live;\n          }\n          if (this.paths[toChecksumAddress(address)] === undefined) {\n            changed = true;\n          }\n          this.paths[toChecksumAddress(address)] = path;\n        }\n      } catch (e) {\n        throw new Error(`KeystoneError#invalid_data: ${e}`);\n      }\n    });\n    return changed;\n  };\n\n  //initial read\n  async readKeyring(): Promise<void> {\n    const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();\n    this.syncKeyring(result);\n  }\n\n  public syncKeyring(data: CryptoHDKey | CryptoAccount): void {\n    if (\n      data.getRegistryType().getType() ===\n      extend.RegistryTypes.CRYPTO_HDKEY.getType()\n    ) {\n      this.keyringMode = KEYRING_MODE.hd;\n      this.__readCryptoHDKey(data as CryptoHDKey);\n    } else {\n      this.keyringMode = KEYRING_MODE.pubkey;\n      this.__readCryptoAccount(data as CryptoAccount);\n    }\n  }\n\n  // private __readLedgerLiveAccounts = async () => {\n  //     const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();\n  //     if (result.getRegistryType() === extend.RegistryTypes.CRYPTO_ACCOUNT) {\n  //         const changed = this.__readCryptoAccount(result as CryptoAccount);\n  //         if (!changed) {\n  //             throw new Error(`#KeystoneError#pubkey_account.no_new_account`);\n  //         }\n  //     } else {\n  //         throw new Error(`KeystoneError#pubkey_account.unexpected_urtype`);\n  //     }\n  // };\n\n  public getName = (): string => {\n    return this.name;\n  };\n\n  protected checkKeyring() {\n    if (!this.xfp || !this.xpub || !this.hdPath) {\n      throw new Error(\n        \"KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly\"\n      );\n    }\n  }\n\n  serialize(): Promise<StoredKeyring> {\n    return Promise.resolve({\n      //common\n      initialized: this.initialized,\n      accounts: this.accounts,\n      currentAccount: this.currentAccount,\n      page: this.page,\n      perPage: this.perPage,\n      keyringAccount: this.keyringAccount,\n      keyringMode: this.keyringMode,\n      name: this.name,\n      version: this.version,\n      xfp: this.xfp,\n\n      //hd\n      xpub: this.xpub,\n      hdPath: this.hdPath,\n      childrenPath: this.childrenPath,\n      indexes: this.indexes,\n\n      //pubkey\n      paths: this.paths,\n    });\n  }\n\n  deserialize(opts?: StoredKeyring): void {\n    if (opts) {\n      //common props;\n      this.accounts = opts.accounts;\n      this.currentAccount = opts.currentAccount;\n      this.page = opts.page;\n      this.perPage = opts.perPage;\n      this.name = opts.name;\n      this.initialized = opts.initialized;\n      this.keyringMode = (opts.keyringMode as KEYRING_MODE) || KEYRING_MODE.hd;\n      this.keyringAccount =\n        (opts.keyringAccount as KEYRING_ACCOUNT) || KEYRING_ACCOUNT.standard;\n      this.xfp = opts.xfp;\n\n      //hd props;\n      this.xpub = opts.xpub;\n      this.hdPath = opts.hdPath;\n      this.indexes = opts.indexes;\n\n      this.paths = opts.paths;\n\n      this.childrenPath = opts.childrenPath || DEFAULT_CHILDREN_PATH;\n    }\n  }\n\n  setCurrentAccount(index: number): void {\n    this.currentAccount = index;\n  }\n\n  getCurrentAccount(): number {\n    return this.currentAccount;\n  }\n\n  getCurrentAddress(): string {\n    return this.accounts[this.currentAccount];\n  }\n\n  setAccountToUnlock = (index) => {\n    this.unlockedAccount = parseInt(index, 10);\n  };\n\n  async addAccounts(n = 1): Promise<string[]> {\n    const from = this.unlockedAccount;\n    const to = from + n;\n    const newAccounts = [];\n\n    for (let i = from; i < to; i++) {\n      const address = await this.__addressFromIndex(pathBase, i);\n      newAccounts.push(address);\n      this.page = 0;\n      this.unlockedAccount++;\n    }\n    this.accounts = this.accounts.concat(newAccounts);\n    return this.accounts;\n  }\n\n  getFirstPage(): Promise<PagedAccount[]> {\n    this.page = 0;\n    return this.__getPage(1);\n  }\n\n  getNextPage(): Promise<PagedAccount[]> {\n    return this.__getPage(1);\n  }\n\n  getPreviousPage(): Promise<PagedAccount[]> {\n    return this.__getPage(-1);\n  }\n\n  private __getNormalPage = async (\n    increment: number\n  ): Promise<PagedAccount[]> => {\n    this.page += increment;\n    if (this.page <= 0) {\n      this.page = 1;\n    }\n    const from = (this.page - 1) * this.perPage;\n    const to = from + this.perPage;\n\n    const accounts = [];\n\n    for (let i = from; i < to; i++) {\n      const address = await this.__addressFromIndex(pathBase, i);\n      accounts.push({\n        address,\n        balance: null,\n        index: i,\n      });\n      this.indexes[toChecksumAddress(address)] = i;\n    }\n    return accounts;\n  };\n\n  private __getLedgerLivePage = async (\n    increment: number\n  ): Promise<PagedAccount[]> => {\n    const nextPage = this.page + increment;\n    const from = (nextPage - 1) * this.perPage;\n    const to = from + this.perPage;\n\n    const accounts = [];\n\n    for (let i = from; i < to; i++) {\n      const address = await this.__addressFromIndex(pathBase, i);\n      accounts.push({\n        address,\n        balance: null,\n        index: i,\n      });\n    }\n\n    this.page += increment;\n    return accounts;\n  };\n\n  async __getPage(increment: number): Promise<PagedAccount[]> {\n    if (!this.initialized) {\n      await this.readKeyring();\n    }\n    if (this.keyringMode === KEYRING_MODE.hd) {\n      return this.__getNormalPage(increment);\n    } else {\n      return this.__getLedgerLivePage(increment);\n    }\n  }\n\n  getAccounts() {\n    return Promise.resolve(this.accounts);\n  }\n\n  removeAccount(address: string): void {\n    if (\n      !this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())\n    ) {\n      throw new Error(`Address ${address} not found in this keyring`);\n    }\n    this.accounts = this.accounts.filter(\n      (a) => a.toLowerCase() !== address.toLowerCase()\n    );\n  }\n\n  // tx is an instance of the ethereumjs-transaction class.\n\n  private static serializeTx(tx: Transaction): Buffer {\n    // need use EIP-155\n    // @ts-ignore\n    tx.v = new BN(tx.common.chainId());\n    // @ts-ignore\n    tx.r = new BN(0);\n    // @ts-ignore\n    tx.s = new BN(0);\n    return tx.serialize();\n  }\n\n  async signTransaction(\n    address: string,\n    tx: Transaction\n  ): Promise<Transaction> {\n    const hdPath = await this._pathFromAddress(address);\n    const chainId = tx.common.chainId();\n    const requestId = uuid.v4();\n    const ethSignRequest = EthSignRequest.constructETHRequest(\n      BaseKeyring.serializeTx(tx),\n      DataType.transaction,\n      hdPath,\n      this.xfp,\n      requestId,\n      chainId\n    );\n\n    const { r, s, v } = await this.requestSignature(\n      requestId,\n      ethSignRequest,\n      \"Scan with your Keystone\",\n      'After your Keystone has signed the transaction, click on \"Scan Keystone\" to receive the signature'\n    );\n    const txJson = tx.toJSON();\n    return Transaction.fromTxData(\n      {\n        to: txJson[\"to\"],\n        gasLimit: txJson[\"gasLimit\"],\n        gasPrice: txJson[\"gasPrice\"],\n        data: txJson[\"data\"],\n        nonce: txJson[\"nonce\"],\n        value: txJson[\"value\"],\n        r,\n        s,\n        v,\n      },\n      { common: tx.common }\n    );\n  }\n\n  signMessage(withAccount: string, data: string): Promise<string> {\n    return this.signPersonalMessage(withAccount, data);\n  }\n\n  async signPersonalMessage(\n    withAccount: string,\n    messageHex: string\n  ): Promise<string> {\n    const usignedHex = stripHexPrefix(messageHex);\n    const hdPath = await this._pathFromAddress(withAccount);\n    const requestId = uuid.v4();\n    const ethSignRequest = EthSignRequest.constructETHRequest(\n      Buffer.from(usignedHex, \"hex\"),\n      DataType.personalMessage,\n      hdPath,\n      this.xfp,\n      requestId,\n      undefined,\n      withAccount\n    );\n    const { r, s, v } = await this.requestSignature(\n      requestId,\n      ethSignRequest,\n      \"Scan with your Keystone\",\n      'After your Keystone has signed this message, click on \"Scan Keystone\" to receive the signature'\n    );\n    return \"0x\" + Buffer.concat([r, s, v]).toString(\"hex\");\n  }\n\n  async signTypedData(withAccount: string, typedData: any): Promise<string> {\n    const hdPath = await this._pathFromAddress(withAccount);\n    const requestId = uuid.v4();\n    const ethSignRequest = EthSignRequest.constructETHRequest(\n      Buffer.from(JSON.stringify(typedData), \"utf-8\"),\n      DataType.typedData,\n      hdPath,\n      this.xfp,\n      requestId,\n      undefined,\n      withAccount\n    );\n    const { r, s, v } = await this.requestSignature(\n      requestId,\n      ethSignRequest,\n      \"Scan with your Keystone\",\n      'After your Keystone has signed this data, click on \"Scan Keystone\" to receive the signature'\n    );\n    return \"0x\" + Buffer.concat([r, s, v]).toString(\"hex\");\n  }\n\n  __addressFromIndex = async (pb: string, i: number): Promise<string> => {\n    if (this.keyringMode === KEYRING_MODE.hd) {\n      this.checkKeyring();\n      if (!this.hdk) {\n        // @ts-ignore\n        this.hdk = HDKey.fromExtendedKey(this.xpub);\n      }\n      const childrenPath = this.childrenPath\n        .replace(\"*\", String(i))\n        .replace(/\\*/g, \"0\");\n      const dkey = this.hdk.derive(`${pb}/${childrenPath}`);\n      const address =\n        \"0x\" + publicToAddress(dkey.publicKey, true).toString(\"hex\");\n      return toChecksumAddress(address);\n    } else {\n      const result = Object.keys(this.paths)[i];\n      if (result) {\n        return toChecksumAddress(result);\n      } else {\n        throw new Error(`KeystoneError#pubkey_account.no_expected_account`);\n      }\n    }\n  };\n\n  async _pathFromAddress(address: string): Promise<string> {\n    if (this.keyringMode === KEYRING_MODE.hd) {\n      const checksummedAddress = toChecksumAddress(address);\n      let index = this.indexes[checksummedAddress];\n      if (typeof index === \"undefined\") {\n        for (let i = 0; i < MAX_INDEX; i++) {\n          if (\n            checksummedAddress === (await this.__addressFromIndex(pathBase, i))\n          ) {\n            index = i;\n            break;\n          }\n        }\n      }\n\n      if (typeof index === \"undefined\") {\n        throw new Error(\"Unknown address\");\n      }\n      return `${this.hdPath}/${this.childrenPath\n        .replace(\"*\", index.toString())\n        .replace(/\\*/g, \"0\")}`;\n    } else {\n      const checksummedAddress = toChecksumAddress(address);\n      const path = this.paths[checksummedAddress];\n      if (typeof path === \"undefined\") {\n        throw new Error(\"Unknown address\");\n      }\n      return path;\n    }\n  }\n}\n"],"names":["KEYRING_MODE","KEYRING_ACCOUNT","BaseKeyring","constructor","opts","Error","async","_requestId","signRequest","requestTitle","requestDescription","ethSignature","this","getInteraction","requestSignature","requestIdBuffer","getRequestId","signature","getSignature","uuid","r","slice","s","v","cryptoHDKey","hdPath","getOrigin","getPath","xfp","getSourceFingerprint","_cryptoHDKey$getOrigi","toString","childrenPath","getChildren","name","getName","getNote","standard","keyringAccount","ledger_legacy","xpub","getBip32Key","undefined","initialized","cryptoAccount","getMasterFingerprint","_cryptoAccount$getMas","changed","outputs","getOutputDescriptors","length","forEach","od","getHDKey","key","getKey","path","address","publicToAddress","ledger_live","paths","toChecksumAddress","e","index","unlockedAccount","parseInt","page","increment","from","perPage","to","accounts","i","__addressFromIndex","push","balance","indexes","pb","keyringMode","hd","checkKeyring","hdk","HDKey","fromExtendedKey","replace","String","dkey","derive","publicKey","result","Object","keys","currentAccount","deserialize","readCryptoHDKeyOrCryptoAccount","syncKeyring","data","getRegistryType","getType","extend","RegistryTypes","CRYPTO_HDKEY","__readCryptoHDKey","pubkey","__readCryptoAccount","serialize","Promise","resolve","version","setCurrentAccount","getCurrentAccount","getCurrentAddress","n","newAccounts","concat","getFirstPage","__getPage","getNextPage","getPreviousPage","readKeyring","__getNormalPage","__getLedgerLivePage","getAccounts","removeAccount","map","a","toLowerCase","includes","filter","tx","BN","common","chainId","_pathFromAddress","requestId","ethSignRequest","EthSignRequest","constructETHRequest","serializeTx","DataType","transaction","txJson","toJSON","Transaction","fromTxData","gasLimit","gasPrice","nonce","value","signMessage","withAccount","signPersonalMessage","messageHex","usignedHex","stripHexPrefix","Buffer","personalMessage","typedData","JSON","stringify","checksummedAddress"],"mappings":"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"}