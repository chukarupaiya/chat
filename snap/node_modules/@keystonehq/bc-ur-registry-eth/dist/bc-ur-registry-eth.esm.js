import { RegistryType, RegistryItem, DataItem, CryptoKeypath, PathComponent, extend, patchTags } from '@keystonehq/bc-ur-registry';
export * from '@keystonehq/bc-ur-registry';
import { parse } from 'uuid';
import HDKey from 'hdkey';
import { publicToAddress, toChecksumAddress } from 'ethereumjs-util';

const ExtendedRegistryTypes = {
  ETH_SIGN_REQUEST: /*#__PURE__*/new RegistryType("eth-sign-request", 401),
  ETH_SIGNATAURE: /*#__PURE__*/new RegistryType("eth-signature", 402),
  ETH_NFT_ITEM: /*#__PURE__*/new RegistryType("eth-nft-item", 403)
};

const {
  decodeToDataItem,
  RegistryTypes
} = extend;
var Keys;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signData"] = 2] = "signData";
  Keys[Keys["dataType"] = 3] = "dataType";
  Keys[Keys["chainId"] = 4] = "chainId";
  Keys[Keys["derivationPath"] = 5] = "derivationPath";
  Keys[Keys["address"] = 6] = "address";
  Keys[Keys["origin"] = 7] = "origin";
})(Keys || (Keys = {}));

var DataType;

(function (DataType) {
  DataType[DataType["transaction"] = 1] = "transaction";
  DataType[DataType["typedData"] = 2] = "typedData";
  DataType[DataType["personalMessage"] = 3] = "personalMessage";
  DataType[DataType["typedTransaction"] = 4] = "typedTransaction";
})(DataType || (DataType = {}));

class EthSignRequest extends RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;

    this.getRequestId = () => this.requestId;

    this.getSignData = () => this.signData;

    this.getDataType = () => this.dataType;

    this.getChainId = () => this.chainId;

    this.getDerivationPath = () => this.derivationPath.getPath();

    this.getSourceFingerprint = () => this.derivationPath.getSourceFingerprint();

    this.getSignRequestAddress = () => this.address;

    this.getOrigin = () => this.origin;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys.requestId] = new DataItem(this.requestId, RegistryTypes.UUID.getTag());
      }

      if (this.address) {
        map[Keys.address] = this.address;
      }

      if (this.chainId) {
        map[Keys.chainId] = this.chainId;
      }

      if (this.origin) {
        map[Keys.origin] = this.origin;
      }

      map[Keys.signData] = this.signData;
      map[Keys.dataType] = this.dataType;
      const keyPath = this.derivationPath.toDataItem();
      keyPath.setTag(this.derivationPath.getRegistryType().getTag());
      map[Keys.derivationPath] = keyPath;
      return new DataItem(map);
    };

    this.requestId = args.requestId;
    this.signData = args.signData;
    this.dataType = args.dataType;
    this.chainId = args.chainId;
    this.derivationPath = args.derivationPath;
    this.address = args.address;
    this.origin = args.origin;
  }

  static constructETHRequest(signData, signDataType, hdPath, xfp, uuidString, chainId, address, origin) {
    const paths = hdPath.replace(/[m|M]\//, "").split("/");
    const hdpathObject = new CryptoKeypath(paths.map(path => {
      const index = parseInt(path.replace("'", ""));
      let isHardened = false;

      if (path.endsWith("'")) {
        isHardened = true;
      }

      return new PathComponent({
        index,
        hardened: isHardened
      });
    }), Buffer.from(xfp, "hex"));
    return new EthSignRequest({
      requestId: uuidString ? Buffer.from(parse(uuidString)) : undefined,
      signData,
      dataType: signDataType,
      derivationPath: hdpathObject,
      chainId,
      address: address ? Buffer.from(address.replace("0x", ""), "hex") : undefined,
      origin: origin || undefined
    });
  }

}

EthSignRequest.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signData = map[Keys.signData];
  const dataType = map[Keys.dataType];
  const derivationPath = CryptoKeypath.fromDataItem(map[Keys.derivationPath]);
  const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;
  const address = map[Keys.address] ? map[Keys.address] : undefined;
  const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;
  const origin = map[Keys.origin] ? map[Keys.origin] : undefined;
  return new EthSignRequest({
    requestId,
    signData,
    dataType,
    chainId,
    derivationPath,
    address,
    origin
  });
};

EthSignRequest.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem(_cborPayload);
  return EthSignRequest.fromDataItem(dataItem);
};

const {
  RegistryTypes: RegistryTypes$1,
  decodeToDataItem: decodeToDataItem$1
} = extend;
var Keys$1;

(function (Keys) {
  Keys[Keys["requestId"] = 1] = "requestId";
  Keys[Keys["signature"] = 2] = "signature";
})(Keys$1 || (Keys$1 = {}));

class ETHSignature extends RegistryItem {
  constructor(signature, requestId) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATAURE;

    this.getRequestId = () => this.requestId;

    this.getSignature = () => this.signature;

    this.toDataItem = () => {
      const map = {};

      if (this.requestId) {
        map[Keys$1.requestId] = new DataItem(this.requestId, RegistryTypes$1.UUID.getTag());
      }

      map[Keys$1.signature] = this.signature;
      return new DataItem(map);
    };

    this.signature = signature;
    this.requestId = requestId;
  }

}

ETHSignature.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const signature = map[Keys$1.signature];
  const requestId = map[Keys$1.requestId] ? map[Keys$1.requestId].getData() : undefined;
  return new ETHSignature(signature, requestId);
};

ETHSignature.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$1(_cborPayload);
  return ETHSignature.fromDataItem(dataItem);
};

const {
  decodeToDataItem: decodeToDataItem$2
} = extend;
var Keys$2;

(function (Keys) {
  Keys[Keys["chainId"] = 1] = "chainId";
  Keys[Keys["contractAddress"] = 2] = "contractAddress";
  Keys[Keys["contractName"] = 3] = "contractName";
  Keys[Keys["name"] = 4] = "name";
  Keys[Keys["mediaData"] = 5] = "mediaData";
})(Keys$2 || (Keys$2 = {}));

class ETHNFTItem extends RegistryItem {
  constructor(args) {
    super();

    this.getRegistryType = () => ExtendedRegistryTypes.ETH_NFT_ITEM;

    this.getChainId = () => this.chainId;

    this.getName = () => this.name;

    this.getmediaData = () => this.mediaData;

    this.getContractAddress = () => this.contractAddress;

    this.getContractName = () => this.contractName;

    this.toDataItem = () => {
      const map = {};
      map[Keys$2.chainId] = this.chainId;
      map[Keys$2.name] = this.name;
      map[Keys$2.contractAddress] = this.contractAddress;
      map[Keys$2.contractName] = this.contractName;
      map[Keys$2.mediaData] = this.mediaData;
      return new DataItem(map);
    };

    this.chainId = args.chainId;
    this.name = args.name;
    this.contractAddress = args.contractAddress;
    this.contractName = args.contractName;
    this.mediaData = args.mediaData; // remove the data perfix for android usage
  }

  static constructETHNFTItem(chainId, contractAddress, contractName, name, mediaData) {
    return new ETHNFTItem({
      chainId,
      contractAddress,
      contractName,
      mediaData,
      name
    });
  }

}

ETHNFTItem.fromDataItem = dataItem => {
  const map = dataItem.getData();
  const chainId = map[Keys$2.chainId];
  const name = map[Keys$2.name];
  const mediaData = map[Keys$2.mediaData];
  const contractAddress = map[Keys$2.contractAddress];
  const contractName = map[Keys$2.contractName];
  return new ETHNFTItem({
    chainId,
    name,
    contractAddress,
    contractName,
    mediaData
  });
};

ETHNFTItem.fromCBOR = _cborPayload => {
  const dataItem = decodeToDataItem$2(_cborPayload);
  return ETHNFTItem.fromDataItem(dataItem);
};

// @ts-ignore
const generateAddressFromXpub = (xpub, derivePath) => {
  // @ts-ignore
  const node = HDKey.fromExtendedKey(xpub);
  const publicKey = node.derive(derivePath);
  const address = "0x" + publicToAddress(publicKey.publicKey, true).toString("hex");
  return toChecksumAddress(address);
};
const findHDPathFromAddress = (address, xpub, numberLimit, rootPath) => {
  for (let i = 0; i < numberLimit; i++) {
    const path = `M/0/${i}`;

    const _address = generateAddressFromXpub(xpub, path);

    if (address.toLowerCase() == _address.toLowerCase()) {
      return `${rootPath}/0/${i}`;
    }
  }

  return null;
};

patchTags(Object.values(ExtendedRegistryTypes).filter(rt => !!rt.getTag()).map(rt => rt.getTag()));

export { DataType, ETHNFTItem, ETHSignature, EthSignRequest, findHDPathFromAddress, generateAddressFromXpub };
//# sourceMappingURL=bc-ur-registry-eth.esm.js.map
