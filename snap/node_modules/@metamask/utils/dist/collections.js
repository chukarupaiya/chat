"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _map_1, _set_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrozenSet = exports.FrozenMap = void 0;
/**
 * A {@link ReadonlyMap} that cannot be modified after instantiation.
 * The implementation uses an inner map hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this map.
 */
class FrozenMap {
    constructor(entries) {
        _map_1.set(this, void 0);
        __classPrivateFieldSet(this, _map_1, new Map(entries));
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _map_1).size;
    }
    [(_map_1 = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _map_1)[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _map_1).entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner map.
        return __classPrivateFieldGet(this, _map_1).forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));
    }
    get(key) {
        return __classPrivateFieldGet(this, _map_1).get(key);
    }
    has(key) {
        return __classPrivateFieldGet(this, _map_1).has(key);
    }
    keys() {
        return __classPrivateFieldGet(this, _map_1).keys();
    }
    values() {
        return __classPrivateFieldGet(this, _map_1).values();
    }
    toString() {
        return `FrozenMap(${this.size}) {${this.size > 0
            ? ` ${[...this.entries()]
                .map(([key, value]) => `${String(key)} => ${String(value)}`)
                .join(', ')} `
            : ''}}`;
    }
}
exports.FrozenMap = FrozenMap;
/**
 * A {@link ReadonlySet} that cannot be modified after instantiation.
 * The implementation uses an inner set hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this set.
 */
class FrozenSet {
    constructor(values) {
        _set_1.set(this, void 0);
        __classPrivateFieldSet(this, _set_1, new Set(values));
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _set_1).size;
    }
    [(_set_1 = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _set_1)[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _set_1).entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner set.
        return __classPrivateFieldGet(this, _set_1).forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
    }
    has(value) {
        return __classPrivateFieldGet(this, _set_1).has(value);
    }
    keys() {
        return __classPrivateFieldGet(this, _set_1).keys();
    }
    values() {
        return __classPrivateFieldGet(this, _set_1).values();
    }
    toString() {
        return `FrozenSet(${this.size}) {${this.size > 0
            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `
            : ''}}`;
    }
}
exports.FrozenSet = FrozenSet;
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);
//# sourceMappingURL=collections.js.map