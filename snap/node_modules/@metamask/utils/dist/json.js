"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateJsonAndGetSize = exports.getJsonRpcIdValidator = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.jsonrpc2 = exports.isValidJson = void 0;
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
const misc_1 = require("./misc");
/**
 * Type guard for {@link Json}.
 *
 * @param value - The value to check.
 * @returns Whether the value is valid JSON.
 */
function isValidJson(value) {
    try {
        return fast_deep_equal_1.default(value, JSON.parse(JSON.stringify(value)));
    }
    catch (_) {
        return false;
    }
}
exports.isValidJson = isValidJson;
/**
 * The string '2.0'.
 */
exports.jsonrpc2 = '2.0';
/**
 * Type guard to narrow a JSON-RPC request or notification object to a
 * notification.
 *
 * @param requestOrNotification - The JSON-RPC request or notification to check.
 * @returns Whether the specified JSON-RPC message is a notification.
 */
function isJsonRpcNotification(requestOrNotification) {
    return !misc_1.hasProperty(requestOrNotification, 'id');
}
exports.isJsonRpcNotification = isJsonRpcNotification;
/**
 * Assertion type guard to narrow a JSON-RPC request or notification object to a
 * notification.
 *
 * @param requestOrNotification - The JSON-RPC request or notification to check.
 */
function assertIsJsonRpcNotification(requestOrNotification) {
    if (!isJsonRpcNotification(requestOrNotification)) {
        throw new Error('Not a JSON-RPC notification.');
    }
}
exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
/**
 * Type guard to narrow a JSON-RPC request or notification object to a request.
 *
 * @param requestOrNotification - The JSON-RPC request or notification to check.
 * @returns Whether the specified JSON-RPC message is a request.
 */
function isJsonRpcRequest(requestOrNotification) {
    return misc_1.hasProperty(requestOrNotification, 'id');
}
exports.isJsonRpcRequest = isJsonRpcRequest;
/**
 * Assertion type guard to narrow a JSON-RPC request or notification object to a
 * request.
 *
 * @param requestOrNotification - The JSON-RPC request or notification to check.
 */
function assertIsJsonRpcRequest(requestOrNotification) {
    if (!isJsonRpcRequest(requestOrNotification)) {
        throw new Error('Not a JSON-RPC request.');
    }
}
exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
/**
 * Type guard to narrow a JsonRpcResponse object to a success (or failure).
 *
 * @param response - The response object to check.
 * @returns Whether the response object is a success, i.e. has a `result`
 * property.
 */
function isJsonRpcSuccess(response) {
    return misc_1.hasProperty(response, 'result');
}
exports.isJsonRpcSuccess = isJsonRpcSuccess;
/**
 * Type assertion to narrow a JsonRpcResponse object to a success (or failure).
 *
 * @param response - The response object to check.
 */
function assertIsJsonRpcSuccess(response) {
    if (!isJsonRpcSuccess(response)) {
        throw new Error('Not a successful JSON-RPC response.');
    }
}
exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
/**
 * Type guard to narrow a JsonRpcResponse object to a failure (or success).
 *
 * @param response - The response object to check.
 * @returns Whether the response object is a failure, i.e. has an `error`
 * property.
 */
function isJsonRpcFailure(response) {
    return misc_1.hasProperty(response, 'error');
}
exports.isJsonRpcFailure = isJsonRpcFailure;
/**
 * Type assertion to narrow a JsonRpcResponse object to a failure (or success).
 *
 * @param response - The response object to check.
 */
function assertIsJsonRpcFailure(response) {
    if (!isJsonRpcFailure(response)) {
        throw new Error('Not a failed JSON-RPC response.');
    }
}
exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
/**
 * Gets a function for validating JSON-RPC request / response `id` values.
 *
 * By manipulating the options of this factory, you can control the behavior
 * of the resulting validator for some edge cases. This is useful because e.g.
 * `null` should sometimes but not always be permitted.
 *
 * Note that the empty string (`''`) is always permitted by the JSON-RPC
 * specification, but that kind of sucks and you may want to forbid it in some
 * instances anyway.
 *
 * For more details, see the
 * [JSON-RPC Specification](https://www.jsonrpc.org/specification).
 *
 * @param options - An options object.
 * @param options.permitEmptyString - Whether the empty string (i.e. `''`)
 * should be treated as a valid ID. Default: `true`
 * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)
 * should be treated as valid IDs. Default: `false`
 * @param options.permitNull - Whether `null` should be treated as a valid ID.
 * Default: `true`
 * @returns The JSON-RPC ID validator function.
 */
function getJsonRpcIdValidator(options) {
    const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
    /**
     * Type guard for {@link JsonRpcId}.
     *
     * @param id - The JSON-RPC ID value to check.
     * @returns Whether the given ID is valid per the options given to the
     * factory.
     */
    const isValidJsonRpcId = (id) => {
        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||
            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||
            (permitNull && id === null));
    };
    return isValidJsonRpcId;
}
exports.getJsonRpcIdValidator = getJsonRpcIdValidator;
/**
 * Checks whether a value is JSON serializable and counts the total number
 * of bytes needed to store the serialized version of the value.
 *
 * @param jsObject - Potential JSON serializable object.
 * @param skipSizingProcess - Skip JSON size calculation (default: false).
 * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
 * the value was serializable and a number of bytes that it will use when serialized to JSON.
 */
function validateJsonAndGetSize(jsObject, skipSizingProcess = false) {
    const seenObjects = new Set();
    /**
     * Checks whether a value is JSON serializable and counts the total number
     * of bytes needed to store the serialized version of the value.
     *
     * This function assumes the encoding of the JSON is done in UTF-8.
     *
     * @param value - Potential JSON serializable value.
     * @param skipSizing - Skip JSON size calculation (default: false).
     * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
     * the value was serializable and a number of bytes that it will use when serialized to JSON.
     */
    function getJsonSerializableInfo(value, skipSizing) {
        if (value === undefined) {
            // Return zero for undefined, since these are omitted from JSON serialization
            return [true, 0];
        }
        else if (value === null) {
            // Return already specified constant size for null (special object)
            return [true, skipSizing ? 0 : misc_1.JsonSize.Null];
        }
        // Check and calculate sizes for basic (and some special) types
        const typeOfValue = typeof value;
        try {
            if (typeOfValue === 'function') {
                return [false, 0];
            }
            else if (typeOfValue === 'string' || value instanceof String) {
                return [
                    true,
                    skipSizing
                        ? 0
                        : misc_1.calculateStringSize(value) + misc_1.JsonSize.Quote * 2,
                ];
            }
            else if (typeOfValue === 'boolean' || value instanceof Boolean) {
                if (skipSizing) {
                    return [true, 0];
                }
                // eslint-disable-next-line eqeqeq
                return [true, value == true ? misc_1.JsonSize.True : misc_1.JsonSize.False];
            }
            else if (typeOfValue === 'number' || value instanceof Number) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [true, misc_1.calculateNumberSize(value)];
            }
            else if (value instanceof Date) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [
                    true,
                    // Note: Invalid dates will serialize to null
                    isNaN(value.getDate())
                        ? misc_1.JsonSize.Null
                        : misc_1.JsonSize.Date + misc_1.JsonSize.Quote * 2,
                ];
            }
        }
        catch (_) {
            return [false, 0];
        }
        // If object is not plain and cannot be serialized properly,
        // stop here and return false for serialization
        if (!misc_1.isPlainObject(value) && !Array.isArray(value)) {
            return [false, 0];
        }
        // Circular object detection (handling)
        // Check if the same object already exists
        if (seenObjects.has(value)) {
            return [false, 0];
        }
        // Add new object to the seen objects set
        // Only the plain objects should be added (Primitive types are skipped)
        seenObjects.add(value);
        // Continue object decomposition
        try {
            return [
                true,
                Object.entries(value).reduce((sum, [key, nestedValue], idx, arr) => {
                    // Recursively process next nested object or primitive type
                    // eslint-disable-next-line prefer-const
                    let [valid, size] = getJsonSerializableInfo(nestedValue, skipSizing);
                    if (!valid) {
                        throw new Error('JSON validation did not pass. Validation process stopped.');
                    }
                    // Circular object detection
                    // Once a child node is visited and processed remove it from the set.
                    // This will prevent false positives with the same adjacent objects.
                    seenObjects.delete(value);
                    if (skipSizing) {
                        return 0;
                    }
                    // If the size is 0, the value is undefined and undefined in an array
                    // when serialized will be replaced with null
                    if (size === 0 && Array.isArray(value)) {
                        size = misc_1.JsonSize.Null;
                    }
                    // If the size is 0, that means the object is undefined and
                    // the rest of the object structure will be omitted
                    if (size === 0) {
                        return sum;
                    }
                    // Objects will have be serialized with "key": value,
                    // therefore we include the key in the calculation here
                    const keySize = Array.isArray(value)
                        ? 0
                        : key.length + misc_1.JsonSize.Comma + misc_1.JsonSize.Colon * 2;
                    const separator = idx < arr.length - 1 ? misc_1.JsonSize.Comma : 0;
                    return sum + keySize + size + separator;
                }, 
                // Starts at 2 because the serialized JSON string data (plain text)
                // will minimally contain {}/[]
                skipSizing ? 0 : misc_1.JsonSize.Wrapper * 2),
            ];
        }
        catch (_) {
            return [false, 0];
        }
    }
    return getJsonSerializableInfo(jsObject, skipSizingProcess);
}
exports.validateJsonAndGetSize = validateJsonAndGetSize;
//# sourceMappingURL=json.js.map